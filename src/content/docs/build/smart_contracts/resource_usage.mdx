---
title: Resource Usage
description: A guide in my new Starlight docs site.
draft: true
---
Algorand smart contracts do not have default access to the entire blockchain ledger. Therefore, when a smart contract method needs to access resources such as accounts, assets (ASA), other applications (smart contracts), or box references, these must be provided through the reference (foreign) array during invocation. This page explains what reference arrays are, why they are necessary, the different ways to provide them, and includes a series of code examples.

## Resource Availability

When smart contracts are executed, they may require data stored within the blockchain ledger for evaluation. For this data (resource) to be accessible to the smart contract, it must be made available. When you say, 'A resource is available to the smart contract,' it means that the reference array, referencing the resource, was provided during the invocation and execution of a smart contract method that requires access to that resource.

### What are Reference Arrays?
There are four reference arrays: 
- Accounts(link to accounts page): Reference to Algorand accounts
- assets(ASAs)(link to assets page): Reference to Algorand Standard Assets 
- applications(smart contracts)(link to app page): Reference to an external smart contract
- Boxes(link to box page): Reference to Boxes created within the smart contract

Including necessary resources in the appropriate arrays enables the smart contract to access the necessary data during execution, such as reading an account’s Algo balance or examining the immutable properties of an ASA.
This page explains how data access is managed by a smart contract in version 9 or later of the Algorand Virtual Machine (AVM). For details on earlier AVM versions, refer to the [TEAL specification](https://github.com/algorandfoundation/specs/blob/master/dev/TEAL.md#resource-availability)

By default, the reference arrays are empty, with the exception of the accounts and applications arrays. The Accounts array contains the transaction sender's address, and the Applications array contains the called smart contract ID.

### Types of Resources to make available
Using these four reference arrays, you can make the following six unique ledger items available during smart contract execution: account, asset, application, account+asset, account+application, and application+box.
Accounts and Applications can contain sublists with potentially large datasets. For example, an account may opt into an extensive set of assets or applications (which store the user's local state). Additionally, smart contracts can store potentially unlimited boxes of data within the ledger. For instance, a smart contract might create a unique box of arbitrary data for each user.
Combinations like account+asset, account+application, and application+box refer to cases accessing the sublist resources. For example:
- Account+Asset: To read what the balance of an asset is for a specific account, both the asset and the account reference must be included in the respective reference arrays.
- Account+Application: To access an account's local state of an application, both the account and the application reference must be included in the respective reference arrays.
- Application+Box: To retrieve data from a specific box created by an application, the application and the box reference must be included in the respective reference arrays.

### Inner Transaction Resource Availability
Inner transactions within a contract have access to the contract’s resource availability.
So if a smart contract has an inner transaction calling another smart contract, the inner contract automatically inherits the resource availability of the top-level smart contract. For example, if contract A sends an inner transaction to call a method in contract B that requires access to asset XYZ, providing a reference to asset XYZ when calling contract A allows contract B to share the resource availability of contract A and access asset XYZ.

### Reference Array Constraints and Requirements
There are certain limitations and requirements you need to consider when providing references in the reference arrays:

- The four reference arrays are limited to a combined total of eight values per application transaction. (This limit excludes the default references to the transaction sender’s address and the called smart contract ID)
- The accounts array can contain no more than four accounts.
- The values passed into the reference arrays can change per application transaction.
- When accessing one of the sublists of items, the application transaction must include both the top-level item and the nested list item within the same call. For example, to read an ASA balance for a specific account, the account and the asset must be present in the respective accounts and asset arrays for the given transaction.

### Reason for limited access to resources
To maintain a high level of performance, the AVM restricts how much of the ledger can be viewed within a single contract execution. This is implemented with reference arrays passed with each application call transaction, defining the specific ledger items available during execution. These arrays are the Account, Asset, Application, and Boxes arrays.

### Resource Sharing
Resources are shared across transactions within the same atomic group. This means that if there are two app calls calling different smart contracts in the same atomic group, the two smart contracts share resource availability.

For example, say you have two smart contract call transactions grouped together, transaction #1 and transaction #2. Transaction #1 has asset 123456 in its assets array, and transaction #2 has asset 555555 in its assets array. Both assets are available to both smart contract calls during evaluation.

When accessing a sublist resource (account+asa, account+application local state, application+box), both resources must be in the same transaction’s arrays. For example, you cannot have account A in transaction #1 and asset Z in transaction #2 and then try to get the balance of asset Z for account A. Asset Z and account A must be in the same application transaction. If asset Z and account A are in transaction #1’s arrays, A’s balance for Z is also available to transaction #2 during evaluation.

Because Algorand supports grouping up to 16 transactions simultaneously, this pushes the available resources up to 8x16 or 128 items if all 16 transactions are application transactions.

If an application transaction is grouped with other types of transactions, other resources will be made available to the smart contract called in the application transaction. For example, if an application transaction is grouped with a payment transaction, the payment transaction’s sender and receiver accounts are available to the smart contract. 

If the CloseRemainderTo field is set, that account will also be available to the smart contract. The table below summarizes what each transaction type adds to resource availability.

| Transaction         | Transaction Type | Availability Notes  |                                                                                                           
|---------------------|----------|---------------------|
| Payment             | `pay`    | `txn.Sender`, `txn.Receiver`, and `txn.CloseRemainderTo` (if set) |
| Key Registration    | `keyreg` | `txn.Sender` | 
| Asset Config/Create | `acfg`   | `txn.Sender`, `txn.ConfigAsset`, and the `txn.ConfigAsset` holding of `txn.Sender` | 
| Asset Transfer      | `axfer`  | `txn.Sender`, `txn.AssetReceiver`, `txn.AssetSender` (if set), `txnAssetCloseTo` (if set), `txn.XferAsset`, and the `txn.XferAsset` holding of each of those accounts |
| Asset Freeze        | `afrz`   |      `txn.Sender`, `txn.FreezeAccount`, `txn.FreezeAsset`, and the `txn.FreezeAsset` holding of `txn.FreezeAccount`. The `txn.FreezeAsset` holding of `txn.Sender` is not made available |


:::note
If any application or asset is created within a group of transactions, it is an available resource as long as it is created before it is accessed.
:::

## Different ways to provide references
There are different ways you can provide resource references when calling smart contract methods:
1. Manually input resource references in the reference(foreign) arrays

2. Automatically input resource references in the reference(foreign) arrays with automatic resource population using the AlgoKit Utils library ([TypeScript](https://github.com/algorandfoundation/algokit-utils-ts/blob/40be39f672be19dc244b8e8fb4f5bcbc446d4f50/docs/code/modules/index.md#populateappcallresources) and Python)

3. Pass reference types as arguments to contract methods. (You can only do this for Accounts, Assets, and Applications and not Boxes.) 


## Account reference example
3 different code examples (method 1, 2, 3 specified under “Different ways to provide references)

## Asset reference example
3 different code examples (method 1, 2, 3 specified under “Different ways to provide references)

## App reference example
3 different code examples (method 1, 2, 3 specified under “Different ways to provide references)

## Account + Asset example
3 different code examples (method 1, 2, 3 specified under “Different ways to provide references)

## Account + Application example
3 different code examples (method 1, 2, 3 specified under “Different ways to provide references)

## Application + Box reference example
2 different code examples (method 1, 2 specified under “Different ways to provide references)



