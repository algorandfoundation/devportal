---
title: ""
---
import { Code } from '@astrojs/starlight/components';

<Fragment set:html={`
          <section id="principles-background">
<h1>Principles &amp; Background<a class="headerlink" href="#principles-background" title="Link to this heading">¶</a></h1>
<section id="background">
`} />
## Background

<Fragment set:html={`
<p><strong>Smart contracts</strong> on the Algorand blockchain run on the Algorand Virtual Machine (<a class="reference external" href="https://developer.algorand.org/docs/get-details/dapps/avm/">AVM</a>).
This is a stack based virtual machine, which executes AVM bytecode as part of an <a class="reference external" href="https://developer.algorand.org/docs/get-details/transactions/#application-call-transaction">Application Call transaction</a>.
The official mechanism for generating this bytecode is by submitting TEAL (Transaction Execution Approval Language) to
an Algorand Node to compile.</p>
<p><strong>Smart signatures</strong> have the same basis in the AVM and TEAL, but have a different execution model, one not involving
Application Call transactions. Our focus will primarily be on smart contracts, since they are strictly more powerful
in terms of available AVM functions.</p>
<p>TEAL is a <a class="reference external" href="https://en.wikipedia.org/wiki/Non-structured_programming">non-structured</a>
<a class="reference external" href="https://en.wikipedia.org/wiki/Procedural_programming#Imperative_programming">imperative language</a>
(albeit one with support for procedure calls that can isolate stack changes since v8 with <code class="docutils literal notranslate"><span class="pre">proto</span></code>). Writing TEAL is very
similar to writing assembly code. It goes without saying that this is a particularly common or well-practiced model for
programming these days.</p>
<p>As it stands today, developers wanting to write smart contracts specifically for Algorand have the option of writing
TEAL directly, or using some other mechanism of generating TEAL such as the officially supported <a class="reference external" href="https://pyteal.readthedocs.io/en/stable/">PyTEAL</a>
or the community supported <a class="reference external" href="https://tealish.tinyman.org/en/latest/">tealish</a>.</p>
<p>PyTEAL follows a <a class="reference external" href="https://en.wikipedia.org/wiki/Automatic_programming#Generative_programming">generative programming</a> paradigm,
which is a form of metaprogramming. Naturally, writing programs to generate programs presents an additional hurdle for
developers looking to pick up smart contract development. Tooling support for this is also suboptimal, for example, many
classes of errors resulting from the interaction between the procedural elements of the Python language and the PyTEAL
expression-building framework go unnoticed until the point of TEAL generation, or worse go completely unnoticed, and even
when PyTEAL can/does provide an error it can be difficult to understand.</p>
<p>Tealish provides a higher level procedural language, bearing a passing resemblance to Python, than compiles down to TEAL.
However, it’s still lower level than most developers are used to.
For example, the expression <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">+</span> <span class="pre">2</span> <span class="pre">+</span> <span class="pre">3</span></code>is <a class="reference external" href="https://tealish.tinyman.org/en/latest/language.html#math-logic">not valid in tealish</a>.
Another difference vs a higher level language such as Python is that <a class="reference external" href="https://tealish.tinyman.org/en/latest/language.html#functions">functions can only be declared after the program
entry point logic</a>.
In essence, tealish abstracts away many difficulties with writing plain TEAL,
but it is still essentially more of a transpiler than a compiler.
Furthermore, whilst appearing to have syntax inspired by Python, it both adds and removes many fundamental syntax elements,
presenting an additional learning curve to developers looking to learn blockchain development on Algorand.
Being a bespoke language also means it has a much smaller ecosystem of tooling built around it compared to languages like
Python or JavaScript.</p>
<p>To most developers, the Python programming language needs no introduction. First released in 1991, it’s popularity has
grown steadily over the decades, and as of June 2023 it is consistently ranked as either the most popular langauge,
or second most popular following JavaScript:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://octoverse.github.com/2022/top-programming-languages">GitHub 2022</a></p></li>
<li><p><a class="reference external" href="https://stackoverflow.blog/2023/06/13/developer-survey-results-are-in/">StackOverflow 2023</a></p></li>
<li><p><a class="reference external" href="https://www.tiobe.com/tiobe-index/">Tiobe</a></p></li>
<li><p><a class="reference external" href="https://pypl.github.io/PYPL.html">PYPL</a></p></li>
</ul>
<p>The AlgoKit project is an Algorand Foundation initiative to improve the developer experience on Algorand. Within this
broad remit, two of the key <a class="reference external" href="https://github.com/algorandfoundation/algokit-cli/blob/main/docs/algokit.md#guiding-principles">principles</a>
are to “meet developers where they are” and “leverage existing ecosystem”.
Building a compiler that allows developers to write smart contracts using an idiomatic subset of a high level language
such as Python would make great strides towards both of these goals.</p>
<p>Wyvern was the original internal code name for just such a compiler (now called Puya), one that will transform Python code into valid TEAL
smart contracts. In line with the principle of meeting developers where they are, and recognising the popularity of
JavaScript and TypeScript, a parallel initiative to build a TypeScript to TEAL compiler is <a class="reference external" href="https://tealscript.netlify.app">also underway</a>.</p>
</section>
<section id="principles">
`} />
## Principles

<Fragment set:html={`
<p>The principles listed here should form the basis of our decision-making, both in the design and implementation.</p>
<section id="least-surprise">
`} />
### Least surprise

<Fragment set:html={`
<p>Our primary objective is to assist developers in creating accurate smart contracts right from the
start. The often immutable nature of these contracts - although not always the case - and the
substantial financial value they frequently safeguard, underlines the importance of this goal.</p>
<p>This principle ensures that the code behaves as anticipated by the developer. Specifically, if
you’re a Python developer writing Python smart contract code, you can expect the code to behave
identically to its execution in a standard Python environment.</p>
<p>Furthermore, we believe in promoting explicitness and correctness in contract code and its
associated typing. This approach reduces potential errors and enhances the overall integrity of our
smart contracts. Our commitment is to provide a user-friendly platform that aligns with the
developer’s intuition and experience, ultimately simplifying their work and minimizing the
potential for mistakes.</p>
</section>
<section id="inherited-from-algokit">
`} />
### Inherited from AlgoKit

<Fragment set:html={`
<p>As a part of the AlgoKit project, the principles outlined <a class="reference external" href="https://github.com/algorandfoundation/algokit-cli/blob/main/docs/algokit.md#guiding-principles">there</a>
also apply - to the extent that this project is just one component of AlgoKit.</p>
<section id="leverage-existing-ecosystem">
`} />
#### “Leverage existing ecosystem”

<Fragment set:html={`
<blockquote>
<div><p>AlgoKit functionality gets into the hands of Algorand developers quickly by building on top of the
existing ecosystem wherever possible and aligned to these principles.</p>
</div></blockquote>
<p>In order to leverage as much existing Python tooling as possible, we should strive to maintain the highest level of
compatibility with the Python language (and the reference implementation: CPython).</p>
</section>
<section id="meet-developers-where-they-are">
`} />
#### “Meet developers where they are”

<Fragment set:html={`
<blockquote>
<div><p>Make Blockchain development mainstream by giving all developers an idiomatic development experience in the operating
system, IDE and language they are comfortable with so they can dive in quickly and have less they need to learn before
being productive.</p>
</div></blockquote>
<p>Python is a very idiomatic language. We should embrace accepted patterns and practices as much as possible,
such as those listed in <a class="reference external" href="https://peps.python.org/pep-0020/">PEP-20</a> (aka “The Zen of Python”).</p>
</section>
<section id="extensible">
`} />
#### “Extensible”

<Fragment set:html={`
<blockquote>
<div><p>Be extensible for community contribution rather than stifling innovation, bottle-necking all changes through the
Algorand Foundation and preventing the opportunity for other ecosystems being represented (e.g. Go, Rust, etc.).
This helps make developers feel welcome and is part of the developer experience, plus it makes it easier to add
features sustainably</p>
</div></blockquote>
<p>One way to support this principle in the broader AlgoKit context is by building in a mechanism for reusing
common code between smart contracts, to allow the community to build their own Python packages.</p>
</section>
<section id="sustainable">
`} />
#### “Sustainable”

<Fragment set:html={`
<blockquote>
<div><p>AlgoKit should be built in a flexible fashion with long-term maintenance in mind. Updates to latest patches in
dependencies, Algorand protocol development updates, and community contributions and feedback will all feed in to the
evolution of the software.</p>
</div></blockquote>
<p>Taking this principle further, ensuring the compiler is well-designed (e.g. frontend backend separation,
with a well-thought-out IR) will help with maintaining and improving the implementation over time. For example,
adding in new TEAL language features will be easier, same for implementing new optimisation strategies.</p>
<p>Looking to the future, best practices for smart contract development are rapidly evolving. We shouldn’t tie the
implementation too tightly to a current standard such as ARC-4 - although in that specific example, we would still
aim for first class support, but it shouldn’t be assumed as the only way to write smart contracts.</p>
</section>
<section id="modular-components">
`} />
#### “Modular components”

<Fragment set:html={`
<blockquote>
<div><p>Solution components should be modular and loosely coupled to facilitate efficient parallel development by small,
effective teams, reduced architectural complexity and allowing developers to pick and choose the specific tools and
capabilities they want to use based on their needs and what they are comfortable with.</p>
</div></blockquote>
<p>We will focus on the language and compiler design itself.</p>
<p>An example of a very useful feature, that is strongly related but could be implemented separately instead,
is the ability to run the users code in a unit-testing context, without compilation+deployment first.
This would require implementing in Python some level of simulation of Algorand Nodes / AVM behaviour.</p>
</section>
<section id="secure-by-default">
`} />
#### “Secure by default”

<Fragment set:html={`
<blockquote>
<div><p>Include defaults, patterns and tooling that help developers write secure code and reduce the likelihood of security
incidents in the Algorand ecosystem. This solution should help Algorand be the most secure Blockchain ecosystem.</p>
</div></blockquote>
<p>Enforcing security (which is multi-faceted) at a compiler level is difficult, and is some cases impossible.
The best application of this principle here is to support auditing, which is important and nuanced enough to be
listed below as a separate principle.</p>
</section>
<section id="cohesive-developer-tool-suite-seamless-onramp">
`} />
#### “Cohesive developer tool suite” + “Seamless onramp”

<Fragment set:html={`
<blockquote>
<div><p>Cohesive developer tool suite: Using AlgoKit should feel professional and cohesive, like it was designed to work
together, for the developer; not against them. Developers are guided towards delivering end-to-end, high quality
outcomes on MainNet so they and Algorand are more likely to be successful.</p>
</div></blockquote>
<blockquote>
<div><p>Seamless onramp: New developers have a seamless experience to get started and they are guided into a pit of success
with best practices, supported by great training collateral; you should be able to go from nothing to debugging code
in 5 minutes.</p>
</div></blockquote>
<p>These principles relate more to AlgoKit as a whole, so we can respect them by considering the impacts of our decisions
there more broadly.</p>
</section>
</section>
<section id="abstraction-without-obfuscation">
`} />
### Abstraction without obfuscation

<Fragment set:html={`
<p>Algorand Python is a high level language, with support for things such as branching logic, operator precedence, etc.,
and not a set of “macros” for generating TEAL. As such, developers will not be able to directly influence specific TEAL
output, if this is desirable a language such as <a class="reference external" href="https://tealish.tinyman.org">Tealish</a> is more appropriate.</p>
<p>Whilst this will abstract away certain aspects of the underlying TEAL language, there are certain AVM concerns
(such as op code budgets) that should not be abstracted away. That said, we should strive to generate code this is
cost-effective and unsurprising. Python mechanisms such as dynamic (runtime) dispatch, and also many of its builtin
functions on types such as <code class="docutils literal notranslate"><span class="pre">str</span></code> that are taken for granted, would require large amounts of ops compared to the
Python code it represents.</p>
</section>
<section id="support-auditing">
`} />
### Support auditing

<Fragment set:html={`
<p>Auditing is a critical part of the security process for deploying smart contracts. We want to support this function,
and can do so in two ways:</p>
<ol class="arabic simple">
<li><p>By ensuring the same Python code as input generates identical output each time the compiler
is run regardless of the system it’s running on. This is what might be termed <a class="reference external" href="https://github.com/algorandfoundation/algokit-cli/blob/main/docs/articles/output_stability.md">Output stability</a>.
Ensuring a consistent output regardless of the system it’s run on (assuming the same compiler version), means that
auditing the lower level (ie TEAL) code is possible.</p></li>
<li><p>Although auditing the TEAL code should be possible, being able to easily identify and relate it back to the higher level
code can make auditing the contract logic simpler and easier.</p></li>
</ol>
</section>
<section id="revolution-not-evolution">
`} />
### Revolution, not evolution

