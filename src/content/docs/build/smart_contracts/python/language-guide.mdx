---
title: "Language Guide"
---
import { Code } from '@astrojs/starlight/components';

<Fragment set:html={`
          <section id="language-guide">
<h1>Language Guide<a class="headerlink" href="#language-guide" title="Link to this heading">¶</a></h1>
<p>Algorand Python is conceptually two things:</p>
<ol class="arabic simple">
<li><p>A partial implementation of the Python programming language that runs on the AVM.</p></li>
<li><p>A framework for development of Algorand smart contracts and logic signatures, with Pythonic
interfaces to underlying AVM functionality.</p></li>
</ol>
<p>You can install the Algorand Python types from PyPi:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">algorand-python</span></code></p>
</div></blockquote>
<p>or</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">poetry</span> <span class="pre">add</span> <span class="pre">algorand-python</span></code></p>
</div></blockquote>
<hr class="docutils">
<p>As a partial implementation of the Python programming language, it maintains the syntax and
semantics of Python. The subset of the language that is supported will grow over time, but it will
never be a complete implementation due to the restricted nature of the AVM as an execution
environment. As a trivial example, the <code class="docutils literal notranslate"><span class="pre">async</span></code> and <code class="docutils literal notranslate"><span class="pre">await</span></code> keywords, and all associated features,
do not make sense to implement.</p>
<p>Being a partial implementation of Python means that existing developer tooling like IDE syntax
highlighting, static type checkers, linters, and auto-formatters, will work out-of-the-box. This is
as opposed to an approach to smart contract development that adds or alters language elements or
semantics, which then requires custom developer tooling support, and more importantly, requires the
developer to learn and understand the potentially non-obvious differences from regular Python.</p>
<p>The greatest advantage to maintaining semantic and syntactic compatibility, however, is only
realised in combination with the framework approach. Supplying a set of interfaces representing
smart contract development and AVM functionality required allows for the possibility of
implementing those interfaces in pure Python! This will make it possible in the near future for you
to execute tests against your smart contracts without deploying them to Algorand, and even step
into and break-point debug your code from those tests.</p>
<p>The framework provides interfaces to the underlying AVM types and operations. By virtue of the AVM
being statically typed, these interfaces are also statically typed, and require your code to be as
well.</p>
<p>The most basic types on the AVM are <code class="docutils literal notranslate"><span class="pre">uint64</span></code> and <code class="docutils literal notranslate"><span class="pre">bytes[]</span></code>, representing unsigned 64-bit integers
and byte arrays respectively. These are represented by <a class="reference internal" href="../api-algopy.html#algopy.UInt64" title="algopy.UInt64"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">UInt64</span></code></span></a> and
<a class="reference internal" href="../api-algopy.html#algopy.Bytes" title="algopy.Bytes"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">Bytes</span></code></span></a> in Algorand Python. There are further “bounded” types supported by the AVM
which are backed by these two simple primitives. For example, <code class="docutils literal notranslate"><span class="pre">bigint</span></code> represents a variably sized
(up to 512-bits), unsigned integer, but is actually backed by a <code class="docutils literal notranslate"><span class="pre">bytes[]</span></code>. This is represented by
<a class="reference internal" href="../api-algopy.html#algopy.BigUInt" title="algopy.BigUInt"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">BigUInt</span></code></span></a> in Algorand Python.</p>
<p>Unfortunately, none of these types map to standard Python primitives. In Python, an <code class="docutils literal notranslate"><span class="pre">int</span></code> is
unsigned, and effectively unbounded. A <code class="docutils literal notranslate"><span class="pre">bytes</span></code> similarly is limited only by the memory available,
whereas an AVM <code class="docutils literal notranslate"><span class="pre">bytes[]</span></code> has a maximum length of 4096. In order to both maintain semantic
compatibility and allow for a framework implementation in plain Python that will fail under the
same conditions as when deployed to the AVM, support for Python primitives is
<a class="reference internal" href="../lg-types.html#python-built-in-types"><span class="std std-ref">limited</span></a>.</p>
<p>For more information on the philosophy and design of Algorand Python, please see
<a class="reference internal" href="../principles.html#principles"><span class="std std-ref">“Principles”</span></a>.</p>
<p>If you aren’t familiar with Python, a good place to start before continuing below is with the
<a class="reference external" href="https://docs.python.org/3/tutorial/index.html">official tutorial</a>. Just beware that as mentioned
above, <a class="reference internal" href="../lg-unsupported-python-features.html"><span class="std std-doc">not all features are supported</span></a>.</p>
<section id="table-of-contents">
`} />
## Table of Contents

