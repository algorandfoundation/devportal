---
title: Box Storage
description: A guide in my new Starlight docs site.
---

import { Tabs, TabItem } from '@astrojs/starlight/components';
import { Code } from '@astrojs/starlight/components';
import importedCode from '/src/env.d.ts?raw';
import { Aside } from '@astrojs/starlight/components';
import boxExamplePython from '/examples/smart_contracts/py/storage-box-example.py?raw';
import createBoxDataPython from '/examples/smart_contracts/py/storage-box-create.py?raw';
import readBoxDataPython from '/examples/smart_contracts/py/storage-box-read.py?raw';
import extractBoxDataPython from '/examples/smart_contracts/py/storage-box-extract.py?raw';
import lenBoxDataPython from '/examples/smart_contracts/py/storage-box-len.py?raw';
import deleteBoxDataPython from '/examples/smart_contracts/py/storage-box-delete.py?raw';
import writeBoxDataPython from '/examples/smart_contracts/py/storage-box-write.py?raw';
import existsBoxDataPython from '/examples/smart_contracts/py/storage-box-exists.py?raw';
import {
  readBoxDataTEAL,
  writeBoxDataTEAL,
  extractBoxDataTEAL,
  lenBoxDataTEAL,
  deleteBoxDataTEAL,
  existsBoxDataTEAL
} from '/src/content/code-imports.js';

Boxes are keyed storage segments associated with apps itself. An app can create multiple boxes on-demand, each capable of storing up to 32kb of data. Both the box key and data are stored as byte arrays.
Since the AVM stack supports byte arrays and unsigned integers (uint64), any uint64 variables must be converted to byte arrays before storage in a box.

## Usage of Boxes
Boxes are useful in many scenarios:
- Applications that need larger or unbound contract storage.
- Applications that want to store data per user, but do not wish to require users to opt-in to the contract or need the account data to persist even after the user closes or clears out of the application.
- Applications that have dynamic storage requirements.
- Applications that require larger storage blocks that can not fit in the existing global state key-value pairs.
- Applications that require storing arbitrary maps or hash tables.

## Box Array¶
When interacting with apps via app call transactions, developers need a way to specify which boxes an application will access during execution. The box array is part of the smart contract reference arrays, alongside the apps, accounts, and assets arrays. These arrays define the set of objects the app call will interact with (read, write, or send transactions to).

The box array is an array of pairs: the first element of each pair is an integer specifying the index into the foreign application array, and the second element is the key name of the box to be accessed.

Each entry in the box array allows access to only 1kb of data. For example, if a box is sized to 4kb, the transaction must use four entries in this array. To claim an allotted entry a corresponding app Id and box name need to be added to the box ref array. If you need more than the 1kb associated with that specific box name, you can either specify the box ref entry more than once or, preferably, add “empty” box refs ```[0,””]``` into the array. If you specify 0 as the app Id the box ref is for the application being called.

For example, suppose the contract needs to read “BoxA” which is 1.5kb, and “Box B” which is 2.5kb, this would require four entries in the box ref array and would look something like:

```
boxes=[[0, "BoxA"],[0,"BoxB"], [0,""],[0,""]]
```

The required box I/O budget is based on the sizes of the boxes accessed, not the amount of data read or written. For example, if a contract accesses “Box A” with a size of 2kb and “Box B” with a size of 10 bytes, this requires both boxes be in the box reference array and one additional reference ( ceil((2kb + 10b) / 1kb), which can be an “empty” box reference.

Access budgets are summed across multiple application calls in the same transaction group. For example in a group of two smart contract calls, there is room for 16 array entries (8 per app call), allowing access to 16kb of data. If an application needs to access a 16kb box named “Box A”, it will need to be grouped with one additional application call and the box reference array for each transaction in the group should look similar to this:

Transaction 0: [0,”Box A”],[0,””],[0,””],[0,””],[0,””],[0,””],[0,””],[0,””] Transaction 1: [0,””],[0,””],[0,””],[0,””],[0,””],[0,””],[0,””],[0,””]

Box refs can be added to the boxes array using ```goal``` or any of the SDKs.
```shell {1} showLineNumbers=false frame=terminal
goal app method --app-id=53 --method="add_member2()void" --box="53,str:BoxA" --from=CONP4XZSXVZYA7PGYH7426OCAROGQPBTWBUD2334KPEAZIHY7ZRR653AFY
```

## Minimum Balance Requirement For Boxes¶
Boxes are created by a smart contract and raise the minimum balance requirement (MBR) that must be in the contract's ledger balance. This means that a contract that intends to use boxes, must be funded beforehand.

When a box with name ```n``` and size ```s``` is created, the MBR is raised by ```2500 + 400 * (len(n)+s)``` microAlgos. When the box is destroyed, the minimum balance requirement is decremented by the same amount.

Notice that the key (name) is included as part of the MBR calculation.

For example, if a box is created with the name “BoxA” (a 4 byte long key) and with a size of 1024 bytes, the MBR for the app account increases by 413,700 microAlgos:

``` (2500 per box) + (400 * (box size + key size))
(2500) + (400 * (1024+4)) = 413,700 microAlgos 
```

## Manipulating Box Storage
Box storage offers several abstractions for efficient data handling:

```Box```: Box abstracts the reading and writing of a single value to a single box. The box size will be reconfigured dynamically to fit the size of the value being assigned to it.

```BoxRef```: BoxRef abstracts the reading and writing of boxes containing raw binary data. The size is configured manually, and can be set to values larger than what the AVM can handle in a single value.

```BoxMap```: BoxMap abstracts the reading and writing of a set of boxes using a common key and content type. Each composite key (prefix + key) still needs to be made available to the application via the `boxes` property of the Transaction.

### Allocation
App a can allocate as many boxes as it needs, when it needs them.
App a allocates a box using the ```box_create``` opcode in its TEAL program, specifying the name and the size of the box being allocated.
Boxes can be any size from 0 to 32K bytes.
Box names must be at least 1 byte, at most 64 bytes, and must be unique within app a.
The app account(the smart contract) is responsible for funding the box storage (with an increase to its minimum balance requirement, see below for details).
A box name and app id must be referenced in the boxes array of the app call to be allocated.

Boxes may only be accessed (whether reading or writing) in a Smart Contract’s approval program, not in a clear state program


### Creating a Box¶
The AVM supports two opcodes ```box_create``` and ```box_put``` that can be used to create a box. The box_create opcode takes two parameters, the name and the size in bytes for the created box. The ```box_put``` opcode takes two parameters as well. The first parameter is the name and the second is a byte array to write. Because the AVM limits any element on the stack to 4kb, ```box_put``` can only be used for boxes with length ```<= 4kb.```

Boxes can be created and deleted, but once created, they cannot be resized. At creation time, boxes are filled with 0 bytes up to their requested size. The box’s contents can be changed, but the size is fixed at that point. If a box needs to be resized, the box first must be deleted and then recreated with the new size.

<Tabs syncKey="lang">
  <TabItem label="Python" icon="seti:python">
   <Code code={createBoxDataPython} lang="py" frame="none"  />
  </TabItem>
</Tabs>
Refer [Sinppet Source](https://github.com/Asthay97/puya/blob/feature/kitchen-sink/examples/kitchen-sink/contract.py#L13-L21) to get local storage value for different data types

Box names must be unique within an application. If using ```box_create```, and an existing box name is passed with a different size, the creation will fail. If an existing box name is used with the existing size, the call will return a 0 without modifying the box contents. When creating a new box the call will return a 1. When using ```box_put``` with an existing key name, the put will fail if the size of the second argument (data array) is different from the original box size.

:::note
When creating a box, the key name to be created must be in the box ref array.
:::


### Reading
Boxes can only be manipulated by the smart contract that owns them. While the SDKs and goal cmd tool allow these boxes to be read off-chain, only the smart contract that owns them can read or manipulate them on-chain.
App a is the only app that can read the contents of its boxes on-chain. This on-chain privacy is unique to box storage. Recall that everything can be read by anybody from off-chain using the algod or indexer APIs.
To read box b from app a, the app call must include b in its boxes array.
Read budget: Each box reference in the boxes array allows an app call to access 1K bytes of box state - 1K of “box read budget”. To read a box larger than 1K, multiple box references must be put in the boxes arrays.
The box read budget is shared across the transaction group.
The total box read budget must be larger than the sum of the sizes of all the individual boxes referenced (it is not possible to use this read budget for a part of a box - the whole box is read in).
Box data is unstructured. This is unique to box storage.
A box is referenced by including its app ID and box name.

The AVM provides two opcodes for reading the contents of a box, ```box_get``` and ```box_extract```. The ```box_get``` opcode takes one parameter which is the key name for the box. It reads the entire contents of a box. The box_get opcode returns two values. The top-of-stack is an integer that has the value of 1 or 0. A value of 1 means that the box was found and read. A value of 0 means that the box was not found. The next stack element contains the bytes read if the box exists, else it contains an empty byte array. box_get fails if the box length exceeds 4kb.

<Tabs syncKey="lang">
  <TabItem label="Python" icon="seti:python">
   <Code code={readBoxDataPython} lang="py" frame="none"  />
  </TabItem>
  <TabItem label="TEAL" icon="algorand-icon">
   <Code code={readBoxDataTEAL} lang="TEAL" />
  </TabItem>
</Tabs>
Refer [Sinppet Source](https://github.com/Asthay97/puya/blob/feature/kitchen-sink/examples/kitchen-sink/contract.py#L13-L21) to get local storage value for different data types

::note
 when using either opcode to read the contents of a box, the AVM is limited to reading no more than 4kb at a time. This is because the stack is limited to 4kb entries. For larger boxes, the ```box_extract``` opcode should be used to perform multiple reads to retrieve the entire contents.
:::

<Tabs syncKey="lang">
  <TabItem label="Python" icon="seti:python">
   <Code code={extractBoxDataPython} lang="py" frame="none"  />
  </TabItem>
  <TabItem label="TEAL" icon="algorand-icon">
   <Code code={extractBoxDataTEAL} lang="TEAL" />
  </TabItem>
</Tabs>
Refer [Sinppet Source](https://github.com/Asthay97/puya/blob/feature/kitchen-sink/examples/kitchen-sink/contract.py#L13-L21) to get local storage value for different data types


### Writing
App a is the only app that can write the contents of its boxes.
As with reading, each box ref in the boxes array allows an app call to write 1kb of box state - 1kb of “box write budget”.

The AVM provides two opcodes, box_put and box_replace, to write data to a box. The box_put opcode is described in the previous section. The box_replace opcode takes three parameters, the key name, the starting location and replacement bytes.


<Tabs syncKey="lang">
  <TabItem label="Python" icon="seti:python">
   <Code code={writeBoxDataPython} lang="py" frame="none"  />
  </TabItem>
  <TabItem label="TEAL" icon="algorand-icon">
   <Code code={writeBoxDataTEAL} lang="TEAL" />
  </TabItem>
</Tabs>
Refer [Sinppet Source](https://github.com/Asthay97/puya/blob/feature/kitchen-sink/examples/kitchen-sink/contract.py#L13-L21) to get local storage value for different data types


When using ```box_replace```, the box size can not increase. This means if the replacement bytes, when added to the start byte location, exceed the upper bounds of the box, the call will fail.

The following sections cover the details of manipulating boxes within a smart contract.

### Getting a Box Length¶
The AVM offers the ```box_len``` opcode to retrieve the length of a box. This opcode can also be used to verify the existence of a particular box. The opcode takes the box key name and returns two unsigned integers (uint64). The top-of-stack is either a 0 or 1, where 1 indicates the existence of the box and 0 indicates the box does not exist. The next is the length of the box if it exists, else it is 0.

<Tabs syncKey="lang">
  <TabItem label="Python" icon="seti:python">
   <Code code={lenBoxDataPython} lang="py" frame="none"  />
  </TabItem>
  <TabItem label="TEAL" icon="algorand-icon">
   <Code code={lenBoxDataTEAL} lang="TEAL" />
  </TabItem>
</Tabs>
Refer [Sinppet Source](https://github.com/Asthay97/puya/blob/feature/kitchen-sink/examples/kitchen-sink/contract.py#L13-L21) to get local storage value for different data types

### Deleting a Box¶

Only the app that created a box can delete it. If an app is deleted, its boxes are not deleted. The boxes will not be modifiable but still can be queried using the SDKs. The minimum balance will also be locked. (the correct cleanup design is to look up the boxes from off-chain and call the app to delete all its boxes before deleting the app itself).

The AVM offers the ```box_del``` opcode to delete a box. This opcode takes the box key name. The opcode returns one unsigned integer (uint64) with a value of 0 or 1. A value of 1 indicates the box existed and was deleted. A value of 0 indicates the box did not exist.

<Tabs syncKey="lang">
  <TabItem label="Python" icon="seti:python">
   <Code code={deleteBoxDataPython} lang="py" frame="none"  />
  </TabItem>
  <TabItem label="TEAL" icon="algorand-icon">
   <Code code={deleteBoxDataTEAL} lang="TEAL" />
  </TabItem>
</Tabs>

### Other methods for boxes: 

Boxes exists
<Tabs syncKey="lang">
  <TabItem label="Python" icon="seti:python">
   <Code code={existsBoxDataPython} lang="py" frame="none"  />
  </TabItem>
  <TabItem label="TEAL" icon="algorand-icon">
   <Code code={existsBoxDataTEAL} lang="TEAL" />
  </TabItem>
</Tabs>


Refer [Sinppet Source](https://github.com/Asthay97/puya/blob/feature/kitchen-sink/examples/kitchen-sink/contract.py#L13-L21) to get local storage value for different data types

:::warning
 You must delete all boxes before deleting a contract. If this is not done, the minimum balance for that box is not recoverable
:::

## Summary of Box Operations

For manipulating box storage data like reading, writing, deleting and checking if exists:

TEAL: Different opcodes can be used

| Function          | Description                                     |
| ----------------- | ----------------------------------------------- |
| box_extract    | Get global data for the current app             |
| box_get |  | 
| box_create | Get global data for other app                   |
| box_put    | Set global data to the current app              |
| box_del    | Delete box from the current app         |
| box_len | Check if global data exists for the current app |
| box_replace | Check if global data exists for the other app   |

Python SDK: Different functions of box can be used. The detailed api reference can be found [here](https://algorandfoundation.github.io/puya/api-algopy.html#algopy.Box)

| Function | Description |
|---------------------------|-----------------------------------------------------------|
| GlobalState(type\_) | Initialize a global state with the specified data type |
| get(default) | Get data or a default value if not found |
| maybe() | Get data and a boolean indicating if it exists |


## Example: Storing struct in box map

<Tabs syncKey="lang">
  <TabItem label="Python" icon="seti:python">
   <Code code={boxExamplePython} lang="py" frame="none"  />
  </TabItem>
</Tabs>
Refer [Sinppet Source](https://github.com/Asthay97/puya/blob/feature/kitchen-sink/examples/kitchen-sink/contract.py#L13-L21) to get reference to other examples