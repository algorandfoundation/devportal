---
title: Control Flow
description: Overview of control flow in Algorand smart contracts
---

import { Tabs, TabItem } from '@astrojs/starlight/components';
import RemoteCode from '/src/components/RemoteCode.astro';

Control flow in Algorand smart contracts follows common programming paradigms, with support for if statements, while loops, for loops, and switch/match statements. Both Algorand Python and Algorand TypeScript provide familiar syntax for these constructs.

### If statements

If statements work as you would expect in any programming language. The conditions must be an expression that evaluates to a boolean.

<Tabs syncKey='lang'>
  <TabItem label='Algorand TypeScript' icon='seti:typescript'>
    <RemoteCode
      src='https://raw.githubusercontent.com/algorandfoundation/devportal-code-examples/refs/heads/main/projects/typescript-examples/contracts/ControlFlow/contract.algo.ts'
      snippet='IF_ELSE'
      lang='ts'
      title='If Else'
      frame='none'
    />
  </TabItem>
  <TabItem label='Algorand Python' icon='seti:python'>
    <RemoteCode
      src='https://raw.githubusercontent.com/algorandfoundation/devportal-code-examples/refs/heads/main/projects/python-examples/smart_contracts/control_flow/contract.py'
      snippet='IF_ELSE'
      lang='py'
      title='If Else'
      frame='none'
    />
  </TabItem>
</Tabs>

### Ternary conditions

Ternary conditions allow for compact conditional expressions. The condition must be an expression that evaluates to a boolean.

<Tabs syncKey='lang'>
  <TabItem label='Algorand TypeScript' icon='seti:typescript'>
    <RemoteCode
      src='https://raw.githubusercontent.com/algorandfoundation/devportal-code-examples/refs/heads/main/projects/typescript-examples/contracts/ControlFlow/contract.algo.ts'
      snippet='TERNARY'
      lang='ts'
      title='Ternary'
      frame='none'
    />
  </TabItem>
  <TabItem label='Algorand Python' icon='seti:python'>
    <RemoteCode
      src='https://raw.githubusercontent.com/algorandfoundation/devportal-code-examples/refs/heads/main/projects/python-examples/smart_contracts/control_flow/contract.py'
      snippet='TERNARY'
      lang='py'
      title='Ternary'
      frame='none'
    />
  </TabItem>
</Tabs>

### While loops

While loops iterate as long as the specified condition is true. The condition must be an expression that evaluates to a boolean.

You can use `break` and `continue` statements to control loop execution.

<Tabs syncKey='lang'>
  <TabItem label='Algorand TypeScript' icon='seti:typescript'>
    <RemoteCode
      src='https://raw.githubusercontent.com/algorandfoundation/devportal-code-examples/refs/heads/main/projects/typescript-examples/contracts/ControlFlow/contract.algo.ts'
      snippet='WHILE_LOOP'
      lang='ts'
      title='While Loop'
      frame='none'
    />
  </TabItem>
  <TabItem label='Algorand Python' icon='seti:python'>
    <RemoteCode
      src='https://raw.githubusercontent.com/algorandfoundation/devportal-code-examples/refs/heads/main/projects/python-examples/smart_contracts/control_flow/contract.py'
      snippet='WHILE_LOOP'
      lang='py'
      title='While Loop'
      frame='none'
    />
  </TabItem>
</Tabs>


### For Loops

For loops are used to iterate over sequences, ranges and ARC-4 arrays.

In Algorand Python, utility functions like `uenumerate` and `urange` facilitate creating sequences and ranges of UInt64 numbers, and the built-in `reversed` method works with these. In Algorand TypeScript, standard iteration constructs are available.

Here is an example of how you can use For loops in smart contracts:

<Tabs syncKey='lang'>
  <TabItem label='Algorand TypeScript' icon='seti:typescript'>
    <RemoteCode
      src='https://raw.githubusercontent.com/algorandfoundation/devportal-code-examples/refs/heads/main/projects/typescript-examples/contracts/ControlFlow/contract.algo.ts'
      snippet='FOR_LOOP'
      lang='ts'
      title='For Loop'
      frame='none'
    />
  </TabItem>
  <TabItem label='Algorand Python' icon='seti:python'>
    <RemoteCode
      src='https://raw.githubusercontent.com/algorandfoundation/devportal-code-examples/refs/heads/main/projects/python-examples/smart_contracts/control_flow/contract.py'
      snippet='FOR_LOOP'
      lang='py'
      title='For Loop'
      frame='none'
    />
  </TabItem>
</Tabs>

### Switch or Match Statements

`switch` for TypeScript and `match` for Python provide a clean way to handle multiple conditions. They follow the standard syntax of their respective languages.

<Tabs syncKey='lang'>
  <TabItem label='Algorand TypeScript' icon='seti:typescript'>
    <RemoteCode
      src='https://raw.githubusercontent.com/algorandfoundation/devportal-code-examples/refs/heads/main/projects/typescript-examples/contracts/ControlFlow/contract.algo.ts'
      snippet='SWITCH_CASE'
      lang='ts'
      title='Switch Statement'
      frame='none'
    />
  </TabItem>
  <TabItem label='Algorand Python' icon='seti:python'>
    <RemoteCode
      src='https://raw.githubusercontent.com/algorandfoundation/devportal-code-examples/refs/heads/main/projects/python-examples/smart_contracts/control_flow/contract.py'
      snippet='MATCH'
      lang='py'
      title='Match Statement'
      frame='none'
    />
  </TabItem>
</Tabs>

Note: Captures and patterns are not supported. Currently, there is only support for basic case/switch functionality; pattern matching and guard clauses are not currently supported.

## TEAL Flow Control Opcode

Algorand Python and TypeScript are high-level smart contract languages that allow developers to express control flows in more accessible languages. However, the Algorand Virtual Machine (AVM) executes the Transaction Execution Approval Language (TEAL) flow control opcodes after compilation. TEAL is a low-level assembly language that the AVM understands directly. While developers will write smart contracts in higher-level languages, understanding the underlying TEAL opcodes can be beneficial to comprehend what's happening line by line. The following chart contains all of the control flow opcodes available in TEAL.

| Opcode            | Description                                                                                                                                   |
| ----------------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
| err               | Fail immediately.                                                                                                                             |
| bnz target        | branch to TARGET if value A is not zero                                                                                                       |
| bz target         | branch to TARGET if value A is zero                                                                                                           |
| b target          | branch unconditionally to TARGET                                                                                                              |
| return            | use A as success value; end                                                                                                                   |
| pop               | discard A                                                                                                                                     |
| popn n            | remove N values from the top of the stack                                                                                                     |
| dup               | duplicate A                                                                                                                                   |
| dup2              | duplicate A and B                                                                                                                             |
| dupn n            | duplicate A, N times                                                                                                                          |
| dig n             | Nth value from the top of the stack. dig 0 is equivalent to dup                                                                               |
| bury n            | replace the Nth value from the top of the stack with A. bury 0 fails.                                                                         |
| cover n           | remove top of stack, and place it deeper in the stack such that N elements are above it. Fails if stack depth \<= N.                          |
| uncover n         | remove the value at depth N in the stack and shift above items down so the Nth deep value is on top of the stack. Fails if stack depth \<= N. |
| frame_dig i       | Nth (signed) value from the frame pointer.                                                                                                    |
| frame_bury i      | replace the Nth (signed) value from the frame pointer in the stack with A                                                                     |
| swap              | swaps A and B on stack                                                                                                                        |
| select            | selects one of two values based on top-of-stack: B if C != 0, else A                                                                          |
| assert            | immediately fail unless A is a non-zero number                                                                                                |
| callsub target    | branch unconditionally to TARGET, saving the next instruction on the call stack                                                               |
| proto a r         | Prepare top call frame for a retsub that will assume A args and R return values.                                                              |
| retsub            | pop the top instruction from the call stack and branch to it                                                                                  |
| switch target ... | branch to the Ath label. Continue at following instruction if index A exceeds the number of labels.                                           |
| match target ...  | given match cases from A[1] to A[N], branch to the Ith label where A[I] = B. Continue to the following instruction if no matches are found.   |
