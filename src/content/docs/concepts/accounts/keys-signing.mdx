---
title: Keys and signing
---

import { Image } from 'astro:assets';
import initAccount from '@images/account-overview-Initializing-an-Account.png';
import privKeyMnemonic from '@images/account-overview-Private-Key-Mnemonic.png';
import base64PrivateKey from '@images/account-overview-Base64-Private-Key.png';
import pubPrivKey from '@images/account-overview-public-private-key.png';
import pubKeyAlgorandAddr from '@images/account-Overview-Public-Key-Algorand-Address.png';

To be covered:

1. Retail wallets
2. Institutional KMS systems

### Keys and Addresses

Algorand uses Ed25519 high-speed, high-security elliptic-curve signatures. The keys are produced through standard, open-source cryptographic libraries packaged with each of the SDKs. The key generation algorithm takes a random value as input and outputs two 32-byte arrays, representing a public key and its associated private key. These are also referred to as a public/private key pair. These keys perform essential cryptographic functions like signing data and verifying signatures.

<Image src={pubPrivKey} alt='Public/Private Key Generation' />

Figure: Public/Private Key Generation

For reasons that include the need to make the keys human-readable and robust to human error when transferred, both the public and private keys transform. The output of these transformations is what most developers, and usually all end-users, see. The Algorand developer tools actively seek to mask the complexity involved in these transformations. So unless you are a protocol-level developer modifying cryptographic-related source code, you may never actually encounter the actual public/private key pair.

#### Transformation: Public Key to Algorand Address

The **public key** is transformed into an Algorand address by adding a 4-byte checksum to the end of the public key and then encoding it in base32. The result is what the developer and end-user recognize as an **Algorand address**. The address is 58 characters long.

<Image src={pubKeyAlgorandAddr} alt='Public Key to Algorand Address' />

Figure: Public Key to Algorand Address

:::note
Since users almost never see the true public key, and the Algorand address is a unique mapping back to the public key, the term **public key** is frequently (and inaccurately) used to mean **address**.
:::

#### Transformation: Private Key to base64 private key

A base64 encoded concatenation of the private and public keys is a representation of the private key most commonly used by developers interfacing with the SDKs. It is likely not a representation familiar to end users.

<Image src={base64PrivateKey} alt='Base64 Private Key' />

Figure: Base64 Private Key

#### Transformation: Private Key to 25-word mnemonic

The 25-word mnemonic is the most user-friendly representation of the private key. It is generated by converting the private key bytes into 11-bit integers and then mapping those integers to the [bip-0039 English word list](https://raw.githubusercontent.com/bitcoin/bips/master/bip-0039/english.txt), where integer _n_ maps to the word in the _nth_ position in the list. By itself, this creates a 24-word mnemonic. A checksum is added by taking the first two bytes of the hash of the private key and converting them to 11-bit integers and then to their corresponding word in the word list. This word is added to the end of the 24 words to create a 25-word mnemonic.

This representation is called the private key **mnemonic**. You may also see it referred to as a **passphrase**.

<Image src={privKeyMnemonic} alt='Private Key Mnemonic' />

Figure: Private Key Mnemonic

:::note
Both the base64 representation of a private key and the private key mnemonic are considered **private keys**. Disambiguating them in contexts where the representation is important is important.
:::

To manage keys of an Algorand account and use them for signing, there are several methods and tools available. Here's an overview of key management and signing processes:

1. Using algokey:
   Algorand provides a command-line tool called `algokey` for managing keys. You can use it to generate, export, and import keys, as well as sign transactions. Here are some key commands:

   - Generate a key: `algokey generate`
   - Export a key: `algokey export`
   - Import a key: `algokey import`
   - Sign a transaction: `algokey sign`

   [algokey documentation](https://developer.algorand.org/docs/clis/algokey/algokey/) provides more details on these commands.

2. Using the Python SDK:
   The Python SDK offers several methods for key management and signing:

   - Generate a key: `Wallet.generate_key()`
   - Export a key: `Wallet.export_key()`
   - Import a key: `Wallet.import_key()`
   - Sign a transaction: `Wallet.sign_transaction()`

   [Python SDK documentation](https://py-algorand-sdk.readthedocs.io/en/latest/) lists these methods under the Wallet class.

3. Using the JavaScript SDK:
   With the JavaScript SDK, you can sign a transaction using the following code:

   ```javascript
   const signedTxn = ptxn.signTxn(acct.privateKey);
   ```

   [JavaScript SDK: Sign First Transaction](https://developer.algorand.org/docs/sdks/javascript/#sign-first-transaction) provides this example.

4. Using the Java SDK:
   In the Java SDK, you can sign a transaction like this:

   ```java
   SignedTransaction sptxn = acct.signTransaction(ptxn);
   ```

   [Java SDK: Sign First Transaction](https://developer.algorand.org/docs/sdks/java/#sign-first-transaction) demonstrates this method.

5. Rekeying:
   Algorand supports rekeying, which allows you to change the authorized address for an account. This can be done using the `algokit.rekeyAccount()` function in TypeScript:

   ```typescript
   await algokit.rekeyAccount(
     {
       from: account,
       rekeyTo: newAccount,
       // Other optional parameters
     },
     algod,
   );
   ```

   [AlgoKit Utils - Rekey account](https://developer.algorand.org/docs/get-details/algokit/utils/ts/capabilities/account/#rekey-account) provides more details on rekeying.

6. Participation Keys:
   For consensus participation, Algorand uses participation keys, which are separate from spending keys. These are generated and registered for a specific number of rounds to enhance security.

   [Algorand Consensus documentation](https://developer.algorand.org/docs/get-details/algorand_consensus/) explains the concept of participation keys.

Remember to always keep your private keys secure and never share them. When working with keys, it's crucial to follow best practices for key management to ensure the security of your Algorand accounts.
