---
title: Keys and signing
---

import { LinkCard } from '@astrojs/starlight/components';
import { Image } from 'astro:assets';
import Figure from '/src/components/Figure.astro';
import { Code } from '@astrojs/starlight/components';
import { Tabs, TabItem } from '@astrojs/starlight/components';
import RemoteCode from '/src/components/RemoteCode.astro';
import privKeyMnemonic from '@images/account-overview-Private-Key-Mnemonic.png';
import base64PrivateKey from '@images/account-overview-Base64-Private-Key.png';
import pubPrivKey from '@images/account-overview-public-private-key.png';
import pubKeyAlgorandAddr from '@images/account-Overview-Public-Key-Algorand-Address.png';

Algorand uses **Ed25519 elliptic-curve signatures** to ensure high-speed, secure cryptographic operations. Every account in Algorand is built upon a **public/private key pair**, which plays a crucial role in signing and verifying transactions. To simplify key management and enhance security, Algorand provides various tools and transformations to make key handling more accessible to developers and end users.

This guide explores how public and private key pairs are generated and transformed into user-friendly formats like Algorand addresses, base64 private keys, and mnemonics. It also covers various methods for signing transactions, including direct key management through command-line tools like Algokey, programmatic signing using AlgoKit Utils in Python and TypeScript, and wallet-based signing with Pera Wallet integration.

By understanding these key management and signing methods, developers can ensure secure and efficient transactions on the Algorand network.

### Keys and Addresses

Algorand uses Ed25519 high-speed, high-security elliptic-curve signatures. The keys are produced through standard, open-source cryptographic libraries packaged with each of the SDKs. The key generation algorithm takes a random value as input and outputs two 32-byte arrays, representing a public key and its associated private key. These are also referred to as a public/private key pair. These keys perform essential cryptographic functions like signing data and verifying signatures.

<Figure src={pubPrivKey} alt='Public/Private Key Generation' />

For reasons that include the need to make the keys human-readable and robust to human error when transferred, both the public and private keys transform. The output of these transformations is what most developers, and usually all end-users, see. The Algorand developer tools actively seek to mask the complexity involved in these transformations. So unless you are a protocol-level developer modifying cryptographic-related source code, you may never actually encounter the actual public/private key pair.

#### Transformation: Public Key to Algorand Address

The public key is transformed into an Algorand address by adding a 4-byte checksum to the end of the public key and then encoding it in base32. The result is what the developer and end-user recognize as an Algorand address. The address is 58 characters long.

<Figure src={pubKeyAlgorandAddr} alt='Public Key to Algorand Address' />

:::note
Since users almost never see the true public key, and the Algorand address is a unique mapping back to the public key, the term public key is frequently (and inaccurately) used to mean address.
:::

#### Transformation: Private Key to base64 private key

A base64 encoded concatenation of the private and public keys is a representation of the private key most commonly used by developers interfacing with the SDKs. It is likely not a representation familiar to end users.

<Figure src={base64PrivateKey} alt='Base64 Private Key' />

#### Transformation: Private Key to 25-word mnemonic

The 25-word mnemonic is the most user-friendly representation of the private key. It is generated by converting the private key bytes into 11-bit integers and then mapping those integers to the [bip-0039 English word list](https://raw.githubusercontent.com/bitcoin/bips/master/bip-0039/english.txt), where integer _n_ maps to the word in the _nth_ position in the list. By itself, this creates a 24-word mnemonic. A checksum is added by taking the first two bytes of the hash of the private key and converting them to 11-bit integers and then to their corresponding word in the word list. This word is added to the end of the 24 words to create a 25-word mnemonic.

This representation is called the private key mnemonic. You may also see it referred to as a passphrase.

<Figure src={privKeyMnemonic} alt='Private Key Mnemonic' />

:::note
Both the base64 representation of a private key and the private key mnemonic are considered private keys. Disambiguating them in contexts where the representation is important.
:::

To manage keys of an Algorand account and use them for signing, there are several methods and tools available. Here's an overview of key management and signing processes:

## Signing using accounts

### Using algokey

Algokey is a command-line tool provided by Algorand for managing cryptographic keys. It enables users to generate, export, import, and sign transactions using private keys. To sign a transaction, users need access to their private key, either in the form of a keyfile or mnemonic phrase. The signed transaction can then be submitted to the Algorand network for validation and execution. This process ensures that transactions remain tamper-proof and are executed only by authorized entities. To sign a transaction using an account with algokey, you can use the following command.

```
algokey sign -t transaction.txn -k private_key.key -o signed_transaction.stxn
```

<LinkCard title='Algokey' href='/nodes/reference/artifacts#algokey' />

### Using Algokit utils

AlgoKit Utils simplifies the management of standalone Algorand accounts, signing in both Python and TypeScript by abstracting the complexities of Algorand SDKs, allowing developers to generate new accounts, retrieve existing ones, and manage private keys securely. It also streamlines transaction signing by providing flexible signer management options:

#### Default signer

A default signer is used when no specific signer is provided. This helps streamline transaction signing processes, making it easier for developers to handle transactions without manually specifying signers each time.

<Tabs syncKey='lang'>
  <TabItem label='Utils (Python)' icon='seti:python'>
    <RemoteCode
      src='https://raw.githubusercontent.com/algorandfoundation/devportal-code-examples/refs/heads/main/projects/python-examples/algokit_utils_py_examples/accounts/keys_and_signing.py'
      snippet='DEFAULT_SIGNER'
      lang='py'
      title='Default Signer'
      frame='none'
    />
  </TabItem>
  <TabItem label='Utils (TypeScript)' icon='seti:typescript'>
    <RemoteCode
      src='https://raw.githubusercontent.com/algorandfoundation/devportal-code-examples/refs/heads/main/projects/typescript-examples/algokit-utils-ts/accounts/keys-and-signing.ts'
      snippet='DEFAULT_SIGNER'
      lang='ts'
      title='Default Signer'
      frame='none'
    />
  </TabItem>
</Tabs>

#### Multiple signers

In certain use cases, multiple signers may be required to approve a transaction. This is particularly relevant in scenarios involving multi-signature accounts, where different parties must authorize transactions before they can be executed.
The below code registers multiple transaction signers at once. The `setSignerFromAccount` function tracks the given account for later signing. However, if you are generating accounts via the various methods on AccountManager (like random, fromMnemonic, logicsig, etc.) then they automatically get tracked.

<Tabs syncKey='lang'>
  <TabItem label='Utils (Python)' icon='seti:python'>
    <RemoteCode
      src='https://raw.githubusercontent.com/algorandfoundation/devportal-code-examples/refs/heads/main/projects/python-examples/algokit_utils_py_examples/accounts/keys_and_signing.py'
      snippet='MULTIPLE_SIGNERS'
      lang='py'
      title='Multiple Signers'
      frame='none'
    />
  </TabItem>
  <TabItem label='Utils (TypeScript)' icon='seti:typescript'>
    <RemoteCode
      src='https://raw.githubusercontent.com/algorandfoundation/devportal-code-examples/refs/heads/main/projects/typescript-examples/algokit-utils-ts/accounts/keys-and-signing.ts'
      snippet='MULTIPLE_SIGNERS'
      lang='ts'
      title='Multiple Signers'
      frame='none'
    />
  </TabItem>
</Tabs>

#### Get signer

Get signer helps to retrieve the Transaction Signer for the given sender address, ready to sign a transaction for that sender.If no signer has been registered for that address then the default signer is used if registered and if not then an error is thrown.

<Tabs syncKey='lang'>
  <TabItem label='Utils (Python)' icon='seti:python'>
    <RemoteCode
      src='https://raw.githubusercontent.com/algorandfoundation/devportal-code-examples/refs/heads/main/projects/python-examples/algokit_utils_py_examples/accounts/keys_and_signing.py'
      snippet='GET_SIGNER'
      lang='py'
      title='Get Signer'
      frame='none'
    />
  </TabItem>
  <TabItem label='Utils (TypeScript)' icon='seti:typescript'>
    <RemoteCode
      src='https://raw.githubusercontent.com/algorandfoundation/devportal-code-examples/refs/heads/main/projects/typescript-examples/algokit-utils-ts/accounts/keys-and-signing.ts'
      snippet='GET_SIGNER'
      lang='ts'
      title='Get Signer'
      frame='none'
    />
  </TabItem>
</Tabs>

#### Override signer

Create an unsigned payment transaction and manually sign it. The transaction signer can be specified in the second argument to `addTransaction`.

<Tabs syncKey='lang'>
  <TabItem label='Utils (Python)' icon='seti:python'>
    <RemoteCode
      src='https://raw.githubusercontent.com/algorandfoundation/devportal-code-examples/refs/heads/main/projects/python-examples/algokit_utils_py_examples/accounts/keys_and_signing.py'
      snippet='OVERRIDE_SIGNER'
      lang='py'
      title='Override Signer'
      frame='none'
    />
  </TabItem>
  <TabItem label='Utils (TypeScript)' icon='seti:typescript'>
    <RemoteCode
      src='https://raw.githubusercontent.com/algorandfoundation/devportal-code-examples/refs/heads/main/projects/typescript-examples/algokit-utils-ts/accounts/keys-and-signing.ts'
      snippet='OVERRIDE_SIGNER'
      lang='ts'
      title='Override Signer'
      frame='none'
    />
  </TabItem>
</Tabs>

## Signing using wallets

### Using pera wallet

To sign a transaction using Pera Wallet:

1. Create your transaction: First, you need to create the transaction you want to sign using the Algorand SDK.
2. Generate a QR code or deep link: Instead of signing the transaction directly with a private key, you'll need to generate either a QR code or a deep link that contains the transaction details.
3. User interaction: The user will then use the Pera Wallet app to scan the QR code or click the deep link. This will open the transaction in the Pera Wallet app.
4. Review and sign: In the Pera Wallet app, the user will see the transaction details and can choose to sign it.

For more details, refer to [Transferring Assets](/concepts/assets/transfer).

### HD wallet

(coming soon)
