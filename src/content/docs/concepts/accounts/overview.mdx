---
title: Overview
---

import { Image } from 'astro:assets';
import initAccount from '@images/account-overview-Initializing-an-Account.png';
import privKeyMnemonic from '@images/account-overview-Private-Key-Mnemonic.png';
import base64PrivateKey from '@images/account-overview-Base64-Private-Key.png';
import pubPrivKey from '@images/account-overview-public-private-key.png';
import pubKeyAlgorandAddr from '@images/account-overview-Public-Key-Algorand-Address.png';

This section provides an overview of **Accounts** on Algorand. It reviews core terminology and guides developers in interpreting these terms in different contexts.

## Quick start videos

If you prefer videos, take a look at this 10 minute guide to getting started with creating accounts, which also includes using the Pera Algo Wallet.

<iframe
  width='100%'
  style='aspect-ratio:16/9'
  src='https://www.youtube-nocookie.com/embed/TnpGO0P0BA0'
  title='YouTube video player'
  frameborder='0'
  allow='accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share'
  allowfullscreen
></iframe>

## Terminology

### Keys and Addresses

Algorand uses Ed25519 high-speed, high-security elliptic-curve signatures. The keys are produced through standard, open-source cryptographic libraries packaged with each of the SDKs. The key generation algorithm takes a random value as input and outputs two 32-byte arrays, representing a public key and its associated private key. These are also referred to as a public/private key pair. These keys perform essential cryptographic functions like signing data and verifying signatures.

<Image src={pubPrivKey} alt='Public/Private Key Generation' />

Figure: Public/Private Key Generation

For reasons that include the need to make the keys human-readable and robust to human error when transferred, both the public and private keys transform. The output of these transformations is what most developers, and usually all end-users, see. The Algorand developer tools actively seek to mask the complexity involved in these transformations. So unless you are a protocol-level developer modifying cryptographic-related source code, you may never actually encounter the actual public/private key pair.

#### Transformation: Public Key to Algorand Address

The **public key** is transformed into an Algorand address by adding a 4-byte checksum to the end of the public key and then encoding it in base32. The result is what the developer and end-user recognize as an **Algorand address**. The address is 58 characters long.

<Image src={pubKeyAlgorandAddr} alt='Public Key to Algorand Address' />

Figure: Public Key to Algorand Address

:::note
Since users almost never see the true public key, and the Algorand address is a unique mapping back to the public key, the term **public key** is frequently (and inaccurately) used to mean **address**.
:::

#### Transformation: Private Key to base64 private key

A base64 encoded concatenation of the private and public keys is a representation of the private key most commonly used by developers interfacing with the SDKs. It is likely not a representation familiar to end users.

<Image src={base64PrivateKey} alt='Base64 Private Key' />

Figure: Base64 Private Key

#### Transformation: Private Key to 25-word mnemonic

The 25-word mnemonic is the most user-friendly representation of the private key. It is generated by converting the private key bytes into 11-bit integers and then mapping those integers to the [bip-0039 English word list](https://raw.githubusercontent.com/bitcoin/bips/master/bip-0039/english.txt), where integer _n_ maps to the word in the _nth_ position in the list. By itself, this creates a 24-word mnemonic. A checksum is added by taking the first two bytes of the hash of the private key and converting them to 11-bit integers and then to their corresponding word in the word list. This word is added to the end of the 24 words to create a 25-word mnemonic.

This representation is called the private key **mnemonic**. You may also see it referred to as a **passphrase**.

<Image src={privKeyMnemonic} alt='Private Key Mnemonic' />

Figure: Private Key Mnemonic

:::note
Both the base64 representation of a private key and the private key mnemonic are considered **private keys**. Disambiguating them in contexts where the representation is important is important.
:::

### Wallets

In the context of Algorand developer tools, wallets refer to wallets generated and managed by the Key Management Daemon (kmd) process. A wallet stores a collection of keys. kmd stores collections of wallets and allows users to perform operations using the keys stored within these wallets. Every wallet is associated with a master key, represented as a 25-word mnemonic, from which all accounts in that wallet are derived. This allows the wallet owner only to need to remember a single passphrase for all of their accounts. Wallets are stored encrypted on disk. See [Wallet-derived (kmd)](/concepts/accounts/create#wallet-derived-kmd) accounts for more details.

### Accounts

Accounts are entities on the Algorand blockchain associated with specific on-chain data, like a balance. An Algorand Address is the identifier for an Algorand account.

After generating a private key and corresponding address, sending Algos to the address on Algorand will initialize its state on the Algorand blockchain.

<Image src={initAccount} alt='Initializing an Account' />

Figure: Initializing an Account

#### Attributes

##### Minimum Balance

Every account on Algorand must have a minimum balance of 100,000 microAlgos. If a transaction is sent that would result in a balance lower than the minimum, the transaction will fail. The minimum balance increases with each asset holding the account (whether the asset was created or owned by the account) and with each application, the account created or opted in. Destroying a created asset, opting out/closing out an owned asset, destroying a created app, or opting out of an opted-in app decreases the minimum balance accordingly.

Read more about assets, applications, and changes to the minimum balance requirement in the [Costs and Constraints](/concepts/smart-contracts/costs-constraints) section.

##### Online/Offline

By default, Algorand accounts are set to **offline**. An **online** account participates in Algorand consensus. For an account to go online, it must generate a participation key and send a special key registration transaction. Read more about [Registering an account online](/protocol/registration).

#### Other Account Types

Creating an Algorand address using a public key is not the only way. A valid address can also be produced from a compiled TEAL contract and through [Multisignature accounts](/concepts/accounts/multisig). These accounts differ in how they authorize spending, but they look like any other account on Algorand. Read more about contract accounts in the [Smart Contracts](/concepts/smart-contracts/apps/#application-account) section.

#### Special Accounts

Two accounts carry special meaning on the Algorand blockchain: the **FeeSink** and the **RewardsPool**. The FeeSink is where all transaction fees are sent. The FeeSink can only be spent on the RewardsPool account. The RewardsPool was first used to distribute rewards to balance holding accounts. Currently, this account is not used.

In addition, the ZeroAddress `AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ` is an address that represents a blank byte array. It is used when you leave an address field blank in a transaction.
Check the fee sink and reward pool addresses in [Network](/protocol/networks) section to know more.

### A note about term usage in these docs

Even in these docs, the use of these terms may be inconsistent. Sometimes, this deliberate style choice ensures clarity around a broader concept. Sometimes, it emphasizes the inherent pairing of a keyâ€™s public and private portions. (e.g., In code examples, it is sometimes more apparent to name variables as such to emphasize the connection between these two entities). Other times, it is to abstract away from the complexity related to generating an account on Algorand. For example, code samples may use terms like "generateAccount" to generate a private key and Algorand address. There is an underlying assumption that this pair will be used as an Algorand account even though, on generation, it is not yet represented on the blockchain and, therefore, is not technically an Algorand account.
