---
title: Blocks
---

Blocks are the fundamental data structures of the Algorand blockchain, representing a batch of transactions that transitions the ledger state from one round to the next. They include essential metadata (like round number and timestamps) and the actual transactions data. Blocks are added through Algorand's Pure Proof of Stake consensus protocol,

## Algorand Block Structure

An Algorand block consists of two main parts:

### Header

The block header contains high-level metadata about the block:

- Round: The block’s height (or index) in the chain.
- Timestamp: The Unix epoch time (in seconds) of block creation.
- Proposer: The account chosen (via VRF) to propose the block.
- Previous Block Hash: Reference linking this block to its predecessor.
- Genesis ID / Hash: Identifiers anchoring the chain back to its genesis block.
- [Other Fields](https://github.com/algorandfoundation/specs/blob/master/dev/ledger.md#blocks)

### Body

The block body is the block's transaction sequence, which describes the sequence of updates (transactions) to the account state and box state. Contains:

- Transactions: All transactions in this round, including payments, asset transfers, application calls (and any inner transactions generated by apps).
- Fees Collected: Sum of fees for the transactions included.

## Algorand Block Fundamentals

### First/Last Valid Rounds

Unlike Ethereum which uses nonces to prevent transaction replay, Algorand uses a validity window specified by first and last valid rounds. This window determines between which blockchain rounds a transaction can be committed to the blockchain.

:::note
Algorand does not have nonces. Instead, two identical transactions cannot be committed to the blockchain. In addition, transactions have a validity window and optional leases. The validity window (aka first/last valid rounds) specifies between which rounds a transaction can be committed to the blockchain.
:::

- First Valid: The earliest round in which the transaction can be included.
- Last Valid: The final round after which the transaction is no longer valid.

The maximum range between first and last valid rounds is 1000 rounds, which provides approximately 1 hour of validity given Algorand's block time.
By carefully selecting these rounds, developers can manage timing or ensure the transaction expires if not promptly processed.

### Average Block Time

Algorand typically confirms blocks every 2.82 seconds on average, this means that typically a transaction executed by a user or a dapp will take this amount of time to be finalized. When designing dApps, consider how block production timing affects user experience and round-based logic.

### Throughput

Algorand is designed for high throughput, supporting thousands of transactions per second (TPS). Each block can hold up to 25,000 transactions, which ensures the network can scale to meet growing demand without sacrificing security or decentralization.

### Finality and No Forking

Unlike some blockchains that require multiple confirmations or risk reorganization (“forks”), Algorand achieves instant finality at the block level. Once a block is certified (via soft vote and certify vote), its transactions are final and cannot be reversed.

## Interaction with Blocks

### Algorand Node Endpoints

```bash
GET /v2/blocks/{round}: Retrieve a complete block (header + transactions).
GET /v2/blocks/{round}/header: Fetch just the block header.
GET /v2/blocks/{round}/hash: Obtain the cryptographic hash of a given block.
```

These REST endpoints typically require an API token (X-Algo-API-Token header).

### Algorand Python and Typescript

## Block Fields

- The block's _round_, which matches the round of the state it is transitioning
  into. (The block with round 0 is special in that this block specifies not a
  transition but rather the entire initial state, which is called the _genesis
  state_. This block is correspondingly called the _genesis block_.)
  The round is stored under msgpack key `rnd`.

- The block's _genesis identifier_ and _genesis hash_, which match the
  genesis identifier and hash of the states it transitions between.
  The genesis identifier is stored under msgpack key `gen`, and the genesis
  hash is stored under msgpack key `gh`.

- The block's _upgrade vote_, which results in the new upgrade state. The
  block also duplicates the upgrade state of the state it transitions into.
  The msgpack representation of the components of the upgrade vote are described
  in detail below.

- The block's _timestamp_, which matches the timestamp of the state it
  transitions into. The timestamp is stored under msgpack key `ts`.

- The block's _seed_, which matches the seed of the state it transitions into.
  The seed is stored under msgpack key `seed`.

- The block's _reward updates_, which results in the new reward state. The
  block also duplicates the reward state of the state it transitions into.
  The msgpack representation of the components of the reward updates are described
  in detail below.

- A cryptographic commitment to the block's _transaction sequence_, described
  below, stored under msgpack key `txn`.

- A cryptographic commitment, using SHA256 hash function, to the block's _transaction sequence_, described
  below, stored under msgpack key `txn256`.

- The block's _previous hash_, which is the cryptographic hash of the previous
  block in the sequence. (The previous hash of the genesis block is 0.) The
  previous hash is stored under msgpack key `prev`.

- The block's _transaction counter_, which is the total number of transactions
  issued prior to this block. This count starts from the first block with a
  protocol version that supported the transaction counter. The counter is
  stored in msgpack field `tc`.

- The block's _proposer_, which is the address of the account that
  proposed the block. The proposer is stored in msgpack field `prp`.

- The block's _fees collected_ is the sum of all fees paid by transactions in
  the block and is stored in msgpack field `fc`.

- The potential _bonus incentive_ is the amount, in MicroAlgos, that
  may be paid to the proposer of this block beyond the amount
  available from fees. It is stored in msgpack field `bi`. It may be
  set during a consensus upgrade, or else it must be equal to the
  value from the previous block in most rounds, or be 99% of the
  previous value (rounded down) if the round of this block is 0
  modulo 1,000,000.

- The _proposer payout_ is the actual amount that is moved from the
  $I_f$ to the proposer, and is stored in msgpack field `pp`. If the
  proposer is not eligible, as described below, the _proposer payout_
  must be 0. The proposer payout must not exceed

  - The sum of the _bonus incentive_ and half of the _fees
    collected_.
  - The fee sink balance minus 100,000 microAlgos.

- The block's _expired participation accounts_, which contains an
  optional list of account addresses. These accounts' participation
  key expire by the end of the current round, with exact rules below.
  The list is stored in msgpack key `partupdrmv`.

- The block's _suspended participation accounts_, which contains an
  optional list of account addresses. These accounts are have not
  recently demonstrated that they available and participating, with
  exact rules below. The list is stored in msgpack key `partupdabs`.
