---
title: "algokit_utils.protocols.typed_clients"
---

<a id="module-algokit_utils.protocols.typed_clients"></a>

<a id="algokit-utils-protocols-typed-clients"></a>

<a id="module-contents"></a>

<a id="classes"></a>

## Classes

| [`TypedAppClientProtocol`](#algokit_utils.protocols.typed_clients.TypedAppClientProtocol)   | Base class for protocol classes.   |
|---------------------------------------------------------------------------------------------|------------------------------------|
| [`TypedAppFactoryProtocol`](#algokit_utils.protocols.typed_clients.TypedAppFactoryProtocol) | Base class for protocol classes.   |

<a id="api"></a>

## API

<a id="algokit_utils.protocols.typed_clients.TypedAppClientProtocol"></a>

## *class* algokit_utils.protocols.typed_clients.TypedAppClientProtocol

TypedAppClientProtocol(\*, app_id: int, app_name: str | None = None, default_sender: str | None = None, default_signer: [algosdk.atomic_transaction_composer.TransactionSigner](../algosdk/algosdk.atomic_transaction_composer.mdx#algosdk.atomic_transaction_composer.TransactionSigner) | None = None, algorand: [algokit_utils.algorand.AlgorandClient](algokit_utils.algorand.mdx#algokit_utils.algorand.AlgorandClient), approval_source_map: [algosdk.source_map.SourceMap](../algosdk/algosdk.source_map.mdx#algosdk.source_map.SourceMap) | None = None, clear_source_map: [algosdk.source_map.SourceMap](../algosdk/algosdk.source_map.mdx#algosdk.source_map.SourceMap) | None = None)

Base class for protocol classes.

Protocol classes are defined as::

```none
class Proto(Protocol):
    def meth(self) -> int:
        ...
```

Such classes are primarily used with static type checkers that recognize
structural subtyping (static duck-typing).

For example::

```none
class C:
    def meth(self) -> int:
        return 0

def func(x: Proto) -> int:
    return x.meth()

func(C())  # Passes static type check
```

See PEP 544 for details. Protocol classes decorated with
@typing.runtime_checkable act as simple-minded runtime protocols that check
only the presence of given attributes, ignoring their type signatures.
Protocol classes can be generic, they are defined as::

```none
class GenProto[T](Protocol):
    def meth(self) -> T:
        ...
```

## Initialization

<a id="algokit_utils.protocols.typed_clients.TypedAppFactoryProtocol"></a>

## *class* algokit_utils.protocols.typed_clients.TypedAppFactoryProtocol

TypedAppFactoryProtocol(algorand: [algokit_utils.algorand.AlgorandClient](algokit_utils.algorand.mdx#algokit_utils.algorand.AlgorandClient), \*\*kwargs: Any)

Base class for protocol classes.

Protocol classes are defined as::

```none
class Proto(Protocol):
    def meth(self) -> int:
        ...
```

Such classes are primarily used with static type checkers that recognize
structural subtyping (static duck-typing).

For example::

```none
class C:
    def meth(self) -> int:
        return 0

def func(x: Proto) -> int:
    return x.meth()

func(C())  # Passes static type check
```

See PEP 544 for details. Protocol classes decorated with
@typing.runtime_checkable act as simple-minded runtime protocols that check
only the presence of given attributes, ignoring their type signatures.
Protocol classes can be generic, they are defined as::

```none
class GenProto[T](Protocol):
    def meth(self) -> T:
        ...
```

## Initialization
