---
title: "algopy.arc4"
---

<a id="module-algopy.arc4"></a>

<a id="algopy-arc4"></a>

<a id="module-contents"></a>

<a id="classes"></a>

## Classes

| [`ARC4Client`](#algopy.arc4.ARC4Client)     | Used to provide typed method signatures for ARC4 contracts                                                                                                        |
|---------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [`ARC4Contract`](#algopy.arc4.ARC4Contract) | A contract that conforms to the ARC4 ABI specification, functions decorated with<br/>`@abimethod` or `@baremethod` will form the public interface of the contract |
| [`Address`](#algopy.arc4.Address)           | An alias for an array containing 32 bytes representing an Algorand address                                                                                        |
| [`BigUFixedNxM`](#algopy.arc4.BigUFixedNxM) | An ARC4 UFixed representing a decimal with the number of bits and precision specified.                                                                            |
| [`BigUIntN`](#algopy.arc4.BigUIntN)         | An ARC4 UInt consisting of the number of bits specified.                                                                                                          |
| [`Bool`](#algopy.arc4.Bool)                 | An ARC4 encoded bool                                                                                                                                              |
| [`Byte`](#algopy.arc4.Byte)                 | An ARC4 alias for a UInt8                                                                                                                                         |
| [`DynamicArray`](#algopy.arc4.DynamicArray) | A dynamically sized ARC4 Array of the specified type                                                                                                              |
| [`DynamicBytes`](#algopy.arc4.DynamicBytes) | A variable sized array of bytes                                                                                                                                   |
| [`StaticArray`](#algopy.arc4.StaticArray)   | A fixed length ARC4 Array of the specified type and length                                                                                                        |
| [`String`](#algopy.arc4.String)             | An ARC4 sequence of bytes containing a UTF8 string                                                                                                                |
| [`Struct`](#algopy.arc4.Struct)             | Base class for ARC4 Struct types                                                                                                                                  |
| [`Tuple`](#algopy.arc4.Tuple)               | An ARC4 ABI tuple, containing other ARC4 ABI types                                                                                                                |
| [`UFixedNxM`](#algopy.arc4.UFixedNxM)       | An ARC4 UFixed representing a decimal with the number of bits and precision specified.                                                                            |
| [`UIntN`](#algopy.arc4.UIntN)               | An ARC4 UInt consisting of the number of bits specified.                                                                                                          |

<a id="functions"></a>

## Functions

| [`abimethod`](#algopy.arc4.abimethod)           | Decorator that indicates a method is an ARC4 ABI method.                                    |
|-------------------------------------------------|---------------------------------------------------------------------------------------------|
| [`arc4_create`](#algopy.arc4.arc4_create)       | Provides a typesafe and convenient way of creating an ARC4Contract via an inner transaction |
| [`arc4_signature`](#algopy.arc4.arc4_signature) | Returns the ARC4 encoded method selector for the specified signature                        |
| [`arc4_update`](#algopy.arc4.arc4_update)       | Provides a typesafe and convenient way of updating an ARC4Contract via an inner transaction |
| [`baremethod`](#algopy.arc4.baremethod)         | Decorator that indicates a method is an ARC4 bare method.                                   |
| [`emit`](#algopy.arc4.emit)                     | Emit an ARC-28 event for the provided event signature or name, and provided args.           |

<a id="data"></a>

## Data

| [`UInt128`](#algopy.arc4.UInt128)   | An ARC4 UInt128                                                          |
|-------------------------------------|--------------------------------------------------------------------------|
| [`UInt16`](#algopy.arc4.UInt16)     | An ARC4 UInt16                                                           |
| [`UInt256`](#algopy.arc4.UInt256)   | An ARC4 UInt256                                                          |
| [`UInt32`](#algopy.arc4.UInt32)     | An ARC4 UInt32                                                           |
| [`UInt512`](#algopy.arc4.UInt512)   | An ARC4 UInt512                                                          |
| [`UInt64`](#algopy.arc4.UInt64)     | An ARC4 UInt64                                                           |
| [`UInt8`](#algopy.arc4.UInt8)       | An ARC4 UInt8                                                            |
| [`abi_call`](#algopy.arc4.abi_call) | Provides a typesafe way of calling ARC4 methods via an inner transaction |

<a id="api"></a>

## API

<a id="algopy.arc4.ARC4Client"></a>

## *class* algopy.arc4.ARC4Client

Used to provide typed method signatures for ARC4 contracts

<a id="algopy.arc4.ARC4Contract"></a>

## *class* algopy.arc4.ARC4Contract

A contract that conforms to the ARC4 ABI specification, functions decorated with
`@abimethod` or `@baremethod` will form the public interface of the contract

The approval_program will be implemented by the compiler, and route application args
according to the ARC4 ABI specification

The clear_state_program will by default return True, but can be overridden

<a id="algopy.arc4.ARC4Contract.__init_subclass__"></a>

### *classmethod* \_\_init_subclass_\_(\*, name: str = ..., scratch_slots: [algopy.urange](algopy.mdx#algopy.urange) | tuple[int | [algopy.urange](algopy.mdx#algopy.urange), ...] | list[int | [algopy.urange](algopy.mdx#algopy.urange)] = ..., state_totals: [algopy.StateTotals](algopy.mdx#algopy.StateTotals) = ..., avm_version: int = ...)

When declaring a Contract subclass, options and configuration are passed in
the base class list:

```python
class MyContract(algopy.Contract, name="CustomName"):
    ...
```

:param name:
Will affect the output TEAL file name if there are multiple non-abstract contracts
in the same file.

If the contract is a subclass of algopy.ARC4Contract, `name` will also be used as the
contract name in the ARC-32 application.json, instead of the class name.

:param scratch_slots:
Allows you to mark a slot ID or range of slot IDs as “off limits” to Puya.
These slot ID(s) will never be written to or otherwise manipulating by the compiler itself.
This is particularly useful in combination with `algopy.op.gload_bytes` / `algopy.op.gload_uint64`
which lets a contract in a group transaction read from the scratch slots of another contract
that occurs earlier in the transaction group.

In the case of inheritance, scratch slots reserved become cumulative. It is not an error
to have overlapping ranges or values either, so if a base class contract reserves slots
0-5 inclusive and the derived contract reserves 5-10 inclusive, then within the derived
contract all slots 0-10 will be marked as reserved.

:param state_totals:
Allows defining what values should be used for global and local uint and bytes storage
values when creating a contract. Used when outputting ARC-32 application.json schemas.

If let unspecified, the totals will be determined by the compiler based on state
variables assigned to `self`.

This setting is not inherited, and only applies to the exact `Contract` it is specified
on. If a base class does specify this setting, and a derived class does not, a warning
will be emitted for the derived class. To resolve this warning, `state_totals` must be
specified. Note that it is valid to not provide any arguments to the `StateTotals`
constructor, like so `state_totals=StateTotals()`, in which case all values will be
automatically calculated.
:param avm_version:
Determines which AVM version to use, this affects what operations are supported.
Defaults to value provided supplied on command line (which defaults to current mainnet version)

<a id="algopy.arc4.ARC4Contract.approval_program"></a>

### approval_program() → bool

Represents the program called for all transactions
where `OnCompletion` != `ClearState`

<a id="algopy.arc4.ARC4Contract.clear_state_program"></a>

### clear_state_program() → [algopy.UInt64](algopy.mdx#algopy.UInt64) | bool

Represents the program called when `OnCompletion` == `ClearState`

<a id="algopy.arc4.Address"></a>

## *class* algopy.arc4.Address(value: [algopy.Account](algopy.mdx#algopy.Account) | str | [algopy.Bytes](algopy.mdx#algopy.Bytes) = ..., /)

An alias for an array containing 32 bytes representing an Algorand address

## Initialization

If `value` is a string, it should be a 58 character base32 string,
ie a base32 string-encoded 32 bytes public key + 4 bytes checksum.
If `value` is a Bytes, it’s length checked to be 32 bytes - to avoid this
check, use `Address.from_bytes(...)` instead.
Defaults to the zero-address.

<a id="algopy.arc4.Address.__bool__"></a>

### \_\_bool_\_() → bool

Returns `True` if not equal to the zero address

<a id="algopy.arc4.Address.__eq__"></a>

### \_\_eq_\_(other: [algopy.arc4.Address](#algopy.arc4.Address) | [algopy.Account](algopy.mdx#algopy.Account) | str) → bool

Address equality is determined by the address of another
`arc4.Address`, `Account` or `str`

<a id="algopy.arc4.Address.__getitem__"></a>

### \_\_getitem_\_(index: [algopy.UInt64](algopy.mdx#algopy.UInt64) | int) → algopy.arc4._TArrayItem

Gets the item of the array at provided index

<a id="algopy.arc4.Address.__iter__"></a>

### \_\_iter_\_() → Iterator[algopy.arc4._TArrayItem]

Returns an iterator for the items in the array

<a id="algopy.arc4.Address.__ne__"></a>

### \_\_ne_\_(other: [algopy.arc4.Address](#algopy.arc4.Address) | [algopy.Account](algopy.mdx#algopy.Account) | str) → bool

Address equality is determined by the address of another
`arc4.Address`, `Account` or `str`

<a id="algopy.arc4.Address.__reversed__"></a>

### \_\_reversed_\_() → Iterator[algopy.arc4._TArrayItem]

Returns an iterator for the items in the array, in reverse order

<a id="algopy.arc4.Address.__setitem__"></a>

### \_\_setitem_\_(index: [algopy.UInt64](algopy.mdx#algopy.UInt64) | int, value: algopy.arc4._TArrayItem) → algopy.arc4._TArrayItem

Sets the item of the array at specified index to provided value

<a id="algopy.arc4.Address.bytes"></a>

### *property* bytes *: [algopy.Bytes](algopy.mdx#algopy.Bytes)*

Get the underlying Bytes

<a id="algopy.arc4.Address.copy"></a>

### copy() → Self

Create a copy of this array

<a id="algopy.arc4.Address.from_bytes"></a>

### *classmethod* from_bytes(value: [algopy.Bytes](algopy.mdx#algopy.Bytes) | bytes, /) → Self

Construct an instance from the underlying bytes (no validation)

<a id="algopy.arc4.Address.from_log"></a>

### *classmethod* from_log(log: [algopy.Bytes](algopy.mdx#algopy.Bytes), /) → Self

Load an ABI type from application logs, checking for the ABI return prefix `0x151f7c75`

<a id="algopy.arc4.Address.length"></a>

### *property* length *: [algopy.UInt64](algopy.mdx#algopy.UInt64)*

Returns the current length of the array

<a id="algopy.arc4.Address.native"></a>

### *property* native *: [algopy.Account](algopy.mdx#algopy.Account)*

Return the Account representation of the address after ARC4 decoding

<a id="algopy.arc4.BigUFixedNxM"></a>

## *class* algopy.arc4.BigUFixedNxM(value: str = '0.0', /)

An ARC4 UFixed representing a decimal with the number of bits and precision specified.

Max size: 512 bits

## Initialization

Construct an instance of UFixedNxM where value (v) is determined from the original
decimal value (d) by the formula v = round(d \* (10^M))

<a id="algopy.arc4.BigUFixedNxM.__bool__"></a>

### \_\_bool_\_() → bool

Returns `True` if not equal to zero

<a id="algopy.arc4.BigUFixedNxM.__eq__"></a>

### \_\_eq_\_(other: Self) → bool

Compare for equality, note both operands must be the exact same type

<a id="algopy.arc4.BigUFixedNxM.bytes"></a>

### *property* bytes *: [algopy.Bytes](algopy.mdx#algopy.Bytes)*

Get the underlying Bytes

<a id="algopy.arc4.BigUFixedNxM.from_bytes"></a>

### *classmethod* from_bytes(value: [algopy.Bytes](algopy.mdx#algopy.Bytes) | bytes, /) → Self

Construct an instance from the underlying bytes (no validation)

<a id="algopy.arc4.BigUFixedNxM.from_log"></a>

### *classmethod* from_log(log: [algopy.Bytes](algopy.mdx#algopy.Bytes), /) → Self

Load an ABI type from application logs, checking for the ABI return prefix `0x151f7c75`

<a id="algopy.arc4.BigUIntN"></a>

## *class* algopy.arc4.BigUIntN(value: [algopy.BigUInt](algopy.mdx#algopy.BigUInt) | [algopy.UInt64](algopy.mdx#algopy.UInt64) | int = 0, /)

An ARC4 UInt consisting of the number of bits specified.

Max size: 512 bits

## Initialization

<a id="algopy.arc4.BigUIntN.__bool__"></a>

### \_\_bool_\_() → bool

Returns `True` if not equal to zero

<a id="algopy.arc4.BigUIntN.__eq__"></a>

### \_\_eq_\_(other: [algopy.arc4.UIntN](#algopy.arc4.UIntN)[algopy.arc4._TBitSize] | [algopy.arc4.BigUIntN](#algopy.arc4.BigUIntN)[algopy.arc4._TBitSize] | [algopy.UInt64](algopy.mdx#algopy.UInt64) | [algopy.BigUInt](algopy.mdx#algopy.BigUInt) | int) → bool

Return self==value.

<a id="algopy.arc4.BigUIntN.__ge__"></a>

### \_\_ge_\_(other: [algopy.arc4.UIntN](#algopy.arc4.UIntN)[algopy.arc4._TBitSize] | [algopy.arc4.BigUIntN](#algopy.arc4.BigUIntN)[algopy.arc4._TBitSize] | [algopy.UInt64](algopy.mdx#algopy.UInt64) | [algopy.BigUInt](algopy.mdx#algopy.BigUInt) | int) → bool

Return self\>=value.

<a id="algopy.arc4.BigUIntN.__gt__"></a>

### \_\_gt_\_(other: [algopy.arc4.UIntN](#algopy.arc4.UIntN)[algopy.arc4._TBitSize] | [algopy.arc4.BigUIntN](#algopy.arc4.BigUIntN)[algopy.arc4._TBitSize] | [algopy.UInt64](algopy.mdx#algopy.UInt64) | [algopy.BigUInt](algopy.mdx#algopy.BigUInt) | int) → bool

Return self\>value.

<a id="algopy.arc4.BigUIntN.__le__"></a>

### \_\_le_\_(other: [algopy.arc4.UIntN](#algopy.arc4.UIntN)[algopy.arc4._TBitSize] | [algopy.arc4.BigUIntN](#algopy.arc4.BigUIntN)[algopy.arc4._TBitSize] | [algopy.UInt64](algopy.mdx#algopy.UInt64) | [algopy.BigUInt](algopy.mdx#algopy.BigUInt) | int) → bool

Return self\<=value.

<a id="algopy.arc4.BigUIntN.__lt__"></a>

### \_\_lt_\_(other: [algopy.arc4.UIntN](#algopy.arc4.UIntN)[algopy.arc4._TBitSize] | [algopy.arc4.BigUIntN](#algopy.arc4.BigUIntN)[algopy.arc4._TBitSize] | [algopy.UInt64](algopy.mdx#algopy.UInt64) | [algopy.BigUInt](algopy.mdx#algopy.BigUInt) | int) → bool

Return self\<value.

<a id="algopy.arc4.BigUIntN.__ne__"></a>

### \_\_ne_\_(other: [algopy.arc4.UIntN](#algopy.arc4.UIntN)[algopy.arc4._TBitSize] | [algopy.arc4.BigUIntN](#algopy.arc4.BigUIntN)[algopy.arc4._TBitSize] | [algopy.UInt64](algopy.mdx#algopy.UInt64) | [algopy.BigUInt](algopy.mdx#algopy.BigUInt) | int) → bool

Return self!=value.

<a id="algopy.arc4.BigUIntN.bytes"></a>

### *property* bytes *: [algopy.Bytes](algopy.mdx#algopy.Bytes)*

Get the underlying Bytes

<a id="algopy.arc4.BigUIntN.from_bytes"></a>

### *classmethod* from_bytes(value: [algopy.Bytes](algopy.mdx#algopy.Bytes) | bytes, /) → Self

Construct an instance from the underlying bytes (no validation)

<a id="algopy.arc4.BigUIntN.from_log"></a>

### *classmethod* from_log(log: [algopy.Bytes](algopy.mdx#algopy.Bytes), /) → Self

Load an ABI type from application logs, checking for the ABI return prefix `0x151f7c75`

<a id="algopy.arc4.BigUIntN.native"></a>

### *property* native *: [algopy.BigUInt](algopy.mdx#algopy.BigUInt)*

Return the BigUInt representation of the value after ARC4 decoding

<a id="algopy.arc4.Bool"></a>

## *class* algopy.arc4.Bool(value: bool = False, /)

An ARC4 encoded bool

## Initialization

<a id="algopy.arc4.Bool.__eq__"></a>

### \_\_eq_\_(other: [algopy.arc4.Bool](#algopy.arc4.Bool) | bool) → bool

Return self==value.

<a id="algopy.arc4.Bool.__ne__"></a>

### \_\_ne_\_(other: [algopy.arc4.Bool](#algopy.arc4.Bool) | bool) → bool

Return self!=value.

<a id="algopy.arc4.Bool.bytes"></a>

### *property* bytes *: [algopy.Bytes](algopy.mdx#algopy.Bytes)*

Get the underlying Bytes

<a id="algopy.arc4.Bool.from_bytes"></a>

### *classmethod* from_bytes(value: [algopy.Bytes](algopy.mdx#algopy.Bytes) | bytes, /) → Self

Construct an instance from the underlying bytes (no validation)

<a id="algopy.arc4.Bool.from_log"></a>

### *classmethod* from_log(log: [algopy.Bytes](algopy.mdx#algopy.Bytes), /) → Self

Load an ABI type from application logs, checking for the ABI return prefix `0x151f7c75`

<a id="algopy.arc4.Bool.native"></a>

### *property* native *: bool*

Return the bool representation of the value after ARC4 decoding

<a id="algopy.arc4.Byte"></a>

## *class* algopy.arc4.Byte(value: [algopy.BigUInt](algopy.mdx#algopy.BigUInt) | [algopy.UInt64](algopy.mdx#algopy.UInt64) | int = 0, /)

An ARC4 alias for a UInt8

## Initialization

<a id="algopy.arc4.Byte.__bool__"></a>

### \_\_bool_\_() → bool

Returns `True` if not equal to zero

<a id="algopy.arc4.Byte.__eq__"></a>

### \_\_eq_\_(other: [algopy.arc4.UIntN](#algopy.arc4.UIntN)[algopy.arc4._TBitSize] | [algopy.arc4.BigUIntN](#algopy.arc4.BigUIntN)[algopy.arc4._TBitSize] | [algopy.UInt64](algopy.mdx#algopy.UInt64) | [algopy.BigUInt](algopy.mdx#algopy.BigUInt) | int) → bool

Return self==value.

<a id="algopy.arc4.Byte.__ge__"></a>

### \_\_ge_\_(other: [algopy.arc4.UIntN](#algopy.arc4.UIntN)[algopy.arc4._TBitSize] | [algopy.arc4.BigUIntN](#algopy.arc4.BigUIntN)[algopy.arc4._TBitSize] | [algopy.UInt64](algopy.mdx#algopy.UInt64) | [algopy.BigUInt](algopy.mdx#algopy.BigUInt) | int) → bool

Return self\>=value.

<a id="algopy.arc4.Byte.__gt__"></a>

### \_\_gt_\_(other: [algopy.arc4.UIntN](#algopy.arc4.UIntN)[algopy.arc4._TBitSize] | [algopy.arc4.BigUIntN](#algopy.arc4.BigUIntN)[algopy.arc4._TBitSize] | [algopy.UInt64](algopy.mdx#algopy.UInt64) | [algopy.BigUInt](algopy.mdx#algopy.BigUInt) | int) → bool

Return self\>value.

<a id="algopy.arc4.Byte.__le__"></a>

### \_\_le_\_(other: [algopy.arc4.UIntN](#algopy.arc4.UIntN)[algopy.arc4._TBitSize] | [algopy.arc4.BigUIntN](#algopy.arc4.BigUIntN)[algopy.arc4._TBitSize] | [algopy.UInt64](algopy.mdx#algopy.UInt64) | [algopy.BigUInt](algopy.mdx#algopy.BigUInt) | int) → bool

Return self\<=value.

<a id="algopy.arc4.Byte.__lt__"></a>

### \_\_lt_\_(other: [algopy.arc4.UIntN](#algopy.arc4.UIntN)[algopy.arc4._TBitSize] | [algopy.arc4.BigUIntN](#algopy.arc4.BigUIntN)[algopy.arc4._TBitSize] | [algopy.UInt64](algopy.mdx#algopy.UInt64) | [algopy.BigUInt](algopy.mdx#algopy.BigUInt) | int) → bool

Return self\<value.

<a id="algopy.arc4.Byte.__ne__"></a>

### \_\_ne_\_(other: [algopy.arc4.UIntN](#algopy.arc4.UIntN)[algopy.arc4._TBitSize] | [algopy.arc4.BigUIntN](#algopy.arc4.BigUIntN)[algopy.arc4._TBitSize] | [algopy.UInt64](algopy.mdx#algopy.UInt64) | [algopy.BigUInt](algopy.mdx#algopy.BigUInt) | int) → bool

Return self!=value.

<a id="algopy.arc4.Byte.bytes"></a>

### *property* bytes *: [algopy.Bytes](algopy.mdx#algopy.Bytes)*

Get the underlying Bytes

<a id="algopy.arc4.Byte.from_bytes"></a>

### *classmethod* from_bytes(value: [algopy.Bytes](algopy.mdx#algopy.Bytes) | bytes, /) → Self

Construct an instance from the underlying bytes (no validation)

<a id="algopy.arc4.Byte.from_log"></a>

### *classmethod* from_log(log: [algopy.Bytes](algopy.mdx#algopy.Bytes), /) → Self

Load an ABI type from application logs, checking for the ABI return prefix `0x151f7c75`

<a id="algopy.arc4.Byte.native"></a>

### *property* native *: [algopy.UInt64](algopy.mdx#algopy.UInt64)*

Return the UInt64 representation of the value after ARC4 decoding

<a id="algopy.arc4.DynamicArray"></a>

## *class* algopy.arc4.DynamicArray(\*items: algopy.arc4._TArrayItem)

A dynamically sized ARC4 Array of the specified type

## Initialization

Initializes a new array with items provided

<a id="algopy.arc4.DynamicArray.__add__"></a>

### \_\_add_\_(other: [algopy.arc4.DynamicArray](#algopy.arc4.DynamicArray)[algopy.arc4._TArrayItem] | [algopy.arc4.StaticArray](#algopy.arc4.StaticArray)[algopy.arc4._TArrayItem, algopy.arc4._TArrayLength] | tuple[algopy.arc4._TArrayItem, ...]) → [algopy.arc4.DynamicArray](#algopy.arc4.DynamicArray)[algopy.arc4._TArrayItem]

Concat two arrays together, returning a new array

<a id="algopy.arc4.DynamicArray.__bool__"></a>

### \_\_bool_\_() → bool

Returns `True` if not an empty array

<a id="algopy.arc4.DynamicArray.__getitem__"></a>

### \_\_getitem_\_(index: [algopy.UInt64](algopy.mdx#algopy.UInt64) | int) → algopy.arc4._TArrayItem

Gets the item of the array at provided index

<a id="algopy.arc4.DynamicArray.__iter__"></a>

### \_\_iter_\_() → Iterator[algopy.arc4._TArrayItem]

Returns an iterator for the items in the array

<a id="algopy.arc4.DynamicArray.__reversed__"></a>

### \_\_reversed_\_() → Iterator[algopy.arc4._TArrayItem]

Returns an iterator for the items in the array, in reverse order

<a id="algopy.arc4.DynamicArray.__setitem__"></a>

### \_\_setitem_\_(index: [algopy.UInt64](algopy.mdx#algopy.UInt64) | int, value: algopy.arc4._TArrayItem) → algopy.arc4._TArrayItem

Sets the item of the array at specified index to provided value

<a id="algopy.arc4.DynamicArray.append"></a>

### append(item: algopy.arc4._TArrayItem, /) → None

Append an item to this array

<a id="algopy.arc4.DynamicArray.bytes"></a>

### *property* bytes *: [algopy.Bytes](algopy.mdx#algopy.Bytes)*

Get the underlying Bytes

<a id="algopy.arc4.DynamicArray.copy"></a>

### copy() → Self

Create a copy of this array

<a id="algopy.arc4.DynamicArray.extend"></a>

### extend(other: [algopy.arc4.DynamicArray](#algopy.arc4.DynamicArray)[algopy.arc4._TArrayItem] | [algopy.arc4.StaticArray](#algopy.arc4.StaticArray)[algopy.arc4._TArrayItem, algopy.arc4._TArrayLength] | tuple[algopy.arc4._TArrayItem, ...], /) → None

Extend this array with the contents of another array

<a id="algopy.arc4.DynamicArray.from_bytes"></a>

### *classmethod* from_bytes(value: [algopy.Bytes](algopy.mdx#algopy.Bytes) | bytes, /) → Self

Construct an instance from the underlying bytes (no validation)

<a id="algopy.arc4.DynamicArray.from_log"></a>

### *classmethod* from_log(log: [algopy.Bytes](algopy.mdx#algopy.Bytes), /) → Self

Load an ABI type from application logs, checking for the ABI return prefix `0x151f7c75`

<a id="algopy.arc4.DynamicArray.length"></a>

### *property* length *: [algopy.UInt64](algopy.mdx#algopy.UInt64)*

Returns the current length of the array

<a id="algopy.arc4.DynamicArray.pop"></a>

### pop() → algopy.arc4._TArrayItem

Remove and return the last item of this array

<a id="algopy.arc4.DynamicBytes"></a>

## *class* algopy.arc4.DynamicBytes

A variable sized array of bytes

<a id="algopy.arc4.DynamicBytes.__add__"></a>

### \_\_add_\_(other: [algopy.arc4.DynamicArray](#algopy.arc4.DynamicArray)[algopy.arc4._TArrayItem] | [algopy.arc4.StaticArray](#algopy.arc4.StaticArray)[algopy.arc4._TArrayItem, algopy.arc4._TArrayLength] | tuple[algopy.arc4._TArrayItem, ...]) → [algopy.arc4.DynamicArray](#algopy.arc4.DynamicArray)[algopy.arc4._TArrayItem]

Concat two arrays together, returning a new array

<a id="algopy.arc4.DynamicBytes.__bool__"></a>

### \_\_bool_\_() → bool

Returns `True` if not an empty array

<a id="algopy.arc4.DynamicBytes.__getitem__"></a>

### \_\_getitem_\_(index: [algopy.UInt64](algopy.mdx#algopy.UInt64) | int) → algopy.arc4._TArrayItem

Gets the item of the array at provided index

<a id="algopy.arc4.DynamicBytes.__iter__"></a>

### \_\_iter_\_() → Iterator[algopy.arc4._TArrayItem]

Returns an iterator for the items in the array

<a id="algopy.arc4.DynamicBytes.__reversed__"></a>

### \_\_reversed_\_() → Iterator[algopy.arc4._TArrayItem]

Returns an iterator for the items in the array, in reverse order

<a id="algopy.arc4.DynamicBytes.__setitem__"></a>

### \_\_setitem_\_(index: [algopy.UInt64](algopy.mdx#algopy.UInt64) | int, value: algopy.arc4._TArrayItem) → algopy.arc4._TArrayItem

Sets the item of the array at specified index to provided value

<a id="algopy.arc4.DynamicBytes.append"></a>

### append(item: algopy.arc4._TArrayItem, /) → None

Append an item to this array

<a id="algopy.arc4.DynamicBytes.bytes"></a>

### *property* bytes *: [algopy.Bytes](algopy.mdx#algopy.Bytes)*

Get the underlying Bytes

<a id="algopy.arc4.DynamicBytes.copy"></a>

### copy() → Self

Create a copy of this array

<a id="algopy.arc4.DynamicBytes.extend"></a>

### extend(other: [algopy.arc4.DynamicArray](#algopy.arc4.DynamicArray)[algopy.arc4._TArrayItem] | [algopy.arc4.StaticArray](#algopy.arc4.StaticArray)[algopy.arc4._TArrayItem, algopy.arc4._TArrayLength] | tuple[algopy.arc4._TArrayItem, ...], /) → None

Extend this array with the contents of another array

<a id="algopy.arc4.DynamicBytes.from_bytes"></a>

### *classmethod* from_bytes(value: [algopy.Bytes](algopy.mdx#algopy.Bytes) | bytes, /) → Self

Construct an instance from the underlying bytes (no validation)

<a id="algopy.arc4.DynamicBytes.from_log"></a>

### *classmethod* from_log(log: [algopy.Bytes](algopy.mdx#algopy.Bytes), /) → Self

Load an ABI type from application logs, checking for the ABI return prefix `0x151f7c75`

<a id="algopy.arc4.DynamicBytes.length"></a>

### *property* length *: [algopy.UInt64](algopy.mdx#algopy.UInt64)*

Returns the current length of the array

<a id="algopy.arc4.DynamicBytes.native"></a>

### *property* native *: [algopy.Bytes](algopy.mdx#algopy.Bytes)*

Return the Bytes representation of the address after ARC4 decoding

<a id="algopy.arc4.DynamicBytes.pop"></a>

### pop() → algopy.arc4._TArrayItem

Remove and return the last item of this array

<a id="algopy.arc4.StaticArray"></a>

## *class* algopy.arc4.StaticArray

A fixed length ARC4 Array of the specified type and length

<a id="algopy.arc4.StaticArray.__getitem__"></a>

### \_\_getitem_\_(index: [algopy.UInt64](algopy.mdx#algopy.UInt64) | int) → algopy.arc4._TArrayItem

Gets the item of the array at provided index

<a id="algopy.arc4.StaticArray.__iter__"></a>

### \_\_iter_\_() → Iterator[algopy.arc4._TArrayItem]

Returns an iterator for the items in the array

<a id="algopy.arc4.StaticArray.__reversed__"></a>

### \_\_reversed_\_() → Iterator[algopy.arc4._TArrayItem]

Returns an iterator for the items in the array, in reverse order

<a id="algopy.arc4.StaticArray.__setitem__"></a>

### \_\_setitem_\_(index: [algopy.UInt64](algopy.mdx#algopy.UInt64) | int, value: algopy.arc4._TArrayItem) → algopy.arc4._TArrayItem

Sets the item of the array at specified index to provided value

<a id="algopy.arc4.StaticArray.bytes"></a>

### *property* bytes *: [algopy.Bytes](algopy.mdx#algopy.Bytes)*

Get the underlying Bytes

<a id="algopy.arc4.StaticArray.copy"></a>

### copy() → Self

Create a copy of this array

<a id="algopy.arc4.StaticArray.from_bytes"></a>

### *classmethod* from_bytes(value: [algopy.Bytes](algopy.mdx#algopy.Bytes) | bytes, /) → Self

Construct an instance from the underlying bytes (no validation)

<a id="algopy.arc4.StaticArray.from_log"></a>

### *classmethod* from_log(log: [algopy.Bytes](algopy.mdx#algopy.Bytes), /) → Self

Load an ABI type from application logs, checking for the ABI return prefix `0x151f7c75`

<a id="algopy.arc4.StaticArray.length"></a>

### *property* length *: [algopy.UInt64](algopy.mdx#algopy.UInt64)*

Returns the current length of the array

<a id="algopy.arc4.String"></a>

## *class* algopy.arc4.String(value: [algopy.String](algopy.mdx#algopy.String) | str = '', /)

An ARC4 sequence of bytes containing a UTF8 string

## Initialization

<a id="algopy.arc4.String.__bool__"></a>

### \_\_bool_\_() → bool

Returns `True` if length is not zero

<a id="algopy.arc4.String.__eq__"></a>

### \_\_eq_\_(other: [algopy.arc4.String](#algopy.arc4.String) | [algopy.String](algopy.mdx#algopy.String) | str) → bool

Return self==value.

<a id="algopy.arc4.String.bytes"></a>

### *property* bytes *: [algopy.Bytes](algopy.mdx#algopy.Bytes)*

Get the underlying Bytes

<a id="algopy.arc4.String.from_bytes"></a>

### *classmethod* from_bytes(value: [algopy.Bytes](algopy.mdx#algopy.Bytes) | bytes, /) → Self

Construct an instance from the underlying bytes (no validation)

<a id="algopy.arc4.String.from_log"></a>

### *classmethod* from_log(log: [algopy.Bytes](algopy.mdx#algopy.Bytes), /) → Self

Load an ABI type from application logs, checking for the ABI return prefix `0x151f7c75`

<a id="algopy.arc4.String.native"></a>

### *property* native *: [algopy.String](algopy.mdx#algopy.String)*

Return the String representation of the UTF8 string after ARC4 decoding

<a id="algopy.arc4.Struct"></a>

## *class* algopy.arc4.Struct

Base class for ARC4 Struct types

<a id="algopy.arc4.Struct.bytes"></a>

### *property* bytes *: [algopy.Bytes](algopy.mdx#algopy.Bytes)*

Get the underlying bytes[]

<a id="algopy.arc4.Struct.copy"></a>

### copy() → Self

Create a copy of this struct

<a id="algopy.arc4.Struct.from_bytes"></a>

### *classmethod* from_bytes(value: [algopy.Bytes](algopy.mdx#algopy.Bytes) | bytes, /) → Self

Construct an instance from the underlying bytes[] (no validation)

<a id="algopy.arc4.Struct.from_log"></a>

### *classmethod* from_log(log: [algopy.Bytes](algopy.mdx#algopy.Bytes), /) → Self

Load an ABI type from application logs, checking for the ABI return prefix `0x151f7c75`

<a id="algopy.arc4.Tuple"></a>

## *class* algopy.arc4.Tuple(items: tuple[Unpack[algopy.arc4._TTuple]], /)

An ARC4 ABI tuple, containing other ARC4 ABI types

## Initialization

Construct an ARC4 tuple from a native Python tuple

<a id="algopy.arc4.Tuple.__add__"></a>

### \_\_add_\_()

Return self+value.

<a id="algopy.arc4.Tuple.__contains__"></a>

### \_\_contains_\_()

Return bool(key in self).

<a id="algopy.arc4.Tuple.__delattr__"></a>

### \_\_delattr_\_()

Implement delattr(self, name).

<a id="algopy.arc4.Tuple.__dir__"></a>

### \_\_dir_\_()

Default dir() implementation.

<a id="algopy.arc4.Tuple.__eq__"></a>

### \_\_eq_\_()

Return self==value.

<a id="algopy.arc4.Tuple.__format__"></a>

### \_\_format_\_()

Default object formatter.

Return str(self) if format_spec is empty. Raise TypeError otherwise.

<a id="algopy.arc4.Tuple.__ge__"></a>

### \_\_ge_\_()

Return self\>=value.

<a id="algopy.arc4.Tuple.__getattribute__"></a>

### \_\_getattribute_\_()

Return getattr(self, name).

<a id="algopy.arc4.Tuple.__getitem__"></a>

### \_\_getitem_\_()

Return self[key].

<a id="algopy.arc4.Tuple.__getstate__"></a>

### \_\_getstate_\_()

Helper for pickle.

<a id="algopy.arc4.Tuple.__gt__"></a>

### \_\_gt_\_()

Return self\>value.

<a id="algopy.arc4.Tuple.__hash__"></a>

### \_\_hash_\_()

Return hash(self).

<a id="algopy.arc4.Tuple.__iter__"></a>

### \_\_iter_\_()

Implement iter(self).

<a id="algopy.arc4.Tuple.__le__"></a>

### \_\_le_\_()

Return self\<=value.

<a id="algopy.arc4.Tuple.__len__"></a>

### \_\_len_\_()

Return len(self).

<a id="algopy.arc4.Tuple.__lt__"></a>

### \_\_lt_\_()

Return self\<value.

<a id="algopy.arc4.Tuple.__mul__"></a>

### \_\_mul_\_()

Return self\*value.

<a id="algopy.arc4.Tuple.__ne__"></a>

### \_\_ne_\_()

Return self!=value.

<a id="algopy.arc4.Tuple.__new__"></a>

### \_\_new_\_()

Create and return a new object.  See help(type) for accurate signature.

<a id="algopy.arc4.Tuple.__reduce__"></a>

### \_\_reduce_\_()

Helper for pickle.

<a id="algopy.arc4.Tuple.__reduce_ex__"></a>

### \_\_reduce_ex_\_()

Helper for pickle.

<a id="algopy.arc4.Tuple.__repr__"></a>

### \_\_repr_\_()

Return repr(self).

<a id="algopy.arc4.Tuple.__rmul__"></a>

### \_\_rmul_\_()

Return value\*self.

<a id="algopy.arc4.Tuple.__setattr__"></a>

### \_\_setattr_\_()

Implement setattr(self, name, value).

<a id="algopy.arc4.Tuple.__sizeof__"></a>

### \_\_sizeof_\_()

Size of object in memory, in bytes.

<a id="algopy.arc4.Tuple.__str__"></a>

### \_\_str_\_()

Return str(self).

<a id="algopy.arc4.Tuple.bytes"></a>

### *property* bytes *: [algopy.Bytes](algopy.mdx#algopy.Bytes)*

Get the underlying Bytes

<a id="algopy.arc4.Tuple.copy"></a>

### copy() → Self

Create a copy of this tuple

<a id="algopy.arc4.Tuple.count"></a>

### count()

Return number of occurrences of value.

<a id="algopy.arc4.Tuple.from_bytes"></a>

### *classmethod* from_bytes(value: [algopy.Bytes](algopy.mdx#algopy.Bytes) | bytes, /) → Self

Construct an instance from the underlying bytes (no validation)

<a id="algopy.arc4.Tuple.from_log"></a>

### *classmethod* from_log(log: [algopy.Bytes](algopy.mdx#algopy.Bytes), /) → Self

Load an ABI type from application logs, checking for the ABI return prefix `0x151f7c75`

<a id="algopy.arc4.Tuple.index"></a>

### index()

Return first index of value.

Raises ValueError if the value is not present.

<a id="algopy.arc4.Tuple.native"></a>

### *property* native *: tuple[Unpack[algopy.arc4._TTuple]]*

Convert to a native Python tuple - note that the elements of the tuple
should be considered to be copies of the original elements

<a id="algopy.arc4.UFixedNxM"></a>

## *class* algopy.arc4.UFixedNxM(value: str = '0.0', /)

An ARC4 UFixed representing a decimal with the number of bits and precision specified.

Max size: 64 bits

## Initialization

Construct an instance of UFixedNxM where value (v) is determined from the original
decimal value (d) by the formula v = round(d \* (10^M))

<a id="algopy.arc4.UFixedNxM.__bool__"></a>

### \_\_bool_\_() → bool

Returns `True` if not equal to zero

<a id="algopy.arc4.UFixedNxM.__eq__"></a>

### \_\_eq_\_(other: Self) → bool

Compare for equality, note both operands must be the exact same type

<a id="algopy.arc4.UFixedNxM.bytes"></a>

### *property* bytes *: [algopy.Bytes](algopy.mdx#algopy.Bytes)*

Get the underlying Bytes

<a id="algopy.arc4.UFixedNxM.from_bytes"></a>

### *classmethod* from_bytes(value: [algopy.Bytes](algopy.mdx#algopy.Bytes) | bytes, /) → Self

Construct an instance from the underlying bytes (no validation)

<a id="algopy.arc4.UFixedNxM.from_log"></a>

### *classmethod* from_log(log: [algopy.Bytes](algopy.mdx#algopy.Bytes), /) → Self

Load an ABI type from application logs, checking for the ABI return prefix `0x151f7c75`

<a id="algopy.arc4.UInt128"></a>

## algopy.arc4.UInt128 *: TypeAlias*

None

An ARC4 UInt128

<a id="algopy.arc4.UInt16"></a>

## algopy.arc4.UInt16 *: TypeAlias*

None

An ARC4 UInt16

<a id="algopy.arc4.UInt256"></a>

## algopy.arc4.UInt256 *: TypeAlias*

None

An ARC4 UInt256

<a id="algopy.arc4.UInt32"></a>

## algopy.arc4.UInt32 *: TypeAlias*

None

An ARC4 UInt32

<a id="algopy.arc4.UInt512"></a>

## algopy.arc4.UInt512 *: TypeAlias*

None

An ARC4 UInt512

<a id="algopy.arc4.UInt64"></a>

## algopy.arc4.UInt64 *: TypeAlias*

None

An ARC4 UInt64

<a id="algopy.arc4.UInt8"></a>

## algopy.arc4.UInt8 *: TypeAlias*

None

An ARC4 UInt8

<a id="algopy.arc4.UIntN"></a>

## *class* algopy.arc4.UIntN(value: [algopy.BigUInt](algopy.mdx#algopy.BigUInt) | [algopy.UInt64](algopy.mdx#algopy.UInt64) | int = 0, /)

An ARC4 UInt consisting of the number of bits specified.

Max Size: 64 bits

## Initialization

<a id="algopy.arc4.UIntN.__bool__"></a>

### \_\_bool_\_() → bool

Returns `True` if not equal to zero

<a id="algopy.arc4.UIntN.__eq__"></a>

### \_\_eq_\_(other: [algopy.arc4.UIntN](#algopy.arc4.UIntN)[algopy.arc4._TBitSize] | [algopy.arc4.BigUIntN](#algopy.arc4.BigUIntN)[algopy.arc4._TBitSize] | [algopy.UInt64](algopy.mdx#algopy.UInt64) | [algopy.BigUInt](algopy.mdx#algopy.BigUInt) | int) → bool

Return self==value.

<a id="algopy.arc4.UIntN.__ge__"></a>

### \_\_ge_\_(other: [algopy.arc4.UIntN](#algopy.arc4.UIntN)[algopy.arc4._TBitSize] | [algopy.arc4.BigUIntN](#algopy.arc4.BigUIntN)[algopy.arc4._TBitSize] | [algopy.UInt64](algopy.mdx#algopy.UInt64) | [algopy.BigUInt](algopy.mdx#algopy.BigUInt) | int) → bool

Return self\>=value.

<a id="algopy.arc4.UIntN.__gt__"></a>

### \_\_gt_\_(other: [algopy.arc4.UIntN](#algopy.arc4.UIntN)[algopy.arc4._TBitSize] | [algopy.arc4.BigUIntN](#algopy.arc4.BigUIntN)[algopy.arc4._TBitSize] | [algopy.UInt64](algopy.mdx#algopy.UInt64) | [algopy.BigUInt](algopy.mdx#algopy.BigUInt) | int) → bool

Return self\>value.

<a id="algopy.arc4.UIntN.__le__"></a>

### \_\_le_\_(other: [algopy.arc4.UIntN](#algopy.arc4.UIntN)[algopy.arc4._TBitSize] | [algopy.arc4.BigUIntN](#algopy.arc4.BigUIntN)[algopy.arc4._TBitSize] | [algopy.UInt64](algopy.mdx#algopy.UInt64) | [algopy.BigUInt](algopy.mdx#algopy.BigUInt) | int) → bool

Return self\<=value.

<a id="algopy.arc4.UIntN.__lt__"></a>

### \_\_lt_\_(other: [algopy.arc4.UIntN](#algopy.arc4.UIntN)[algopy.arc4._TBitSize] | [algopy.arc4.BigUIntN](#algopy.arc4.BigUIntN)[algopy.arc4._TBitSize] | [algopy.UInt64](algopy.mdx#algopy.UInt64) | [algopy.BigUInt](algopy.mdx#algopy.BigUInt) | int) → bool

Return self\<value.

<a id="algopy.arc4.UIntN.__ne__"></a>

### \_\_ne_\_(other: [algopy.arc4.UIntN](#algopy.arc4.UIntN)[algopy.arc4._TBitSize] | [algopy.arc4.BigUIntN](#algopy.arc4.BigUIntN)[algopy.arc4._TBitSize] | [algopy.UInt64](algopy.mdx#algopy.UInt64) | [algopy.BigUInt](algopy.mdx#algopy.BigUInt) | int) → bool

Return self!=value.

<a id="algopy.arc4.UIntN.bytes"></a>

### *property* bytes *: [algopy.Bytes](algopy.mdx#algopy.Bytes)*

Get the underlying Bytes

<a id="algopy.arc4.UIntN.from_bytes"></a>

### *classmethod* from_bytes(value: [algopy.Bytes](algopy.mdx#algopy.Bytes) | bytes, /) → Self

Construct an instance from the underlying bytes (no validation)

<a id="algopy.arc4.UIntN.from_log"></a>

### *classmethod* from_log(log: [algopy.Bytes](algopy.mdx#algopy.Bytes), /) → Self

Load an ABI type from application logs, checking for the ABI return prefix `0x151f7c75`

<a id="algopy.arc4.UIntN.native"></a>

### *property* native *: [algopy.UInt64](algopy.mdx#algopy.UInt64)*

Return the UInt64 representation of the value after ARC4 decoding

<a id="algopy.arc4.abi_call"></a>

## algopy.arc4.abi_call *: algopy.arc4._ABICallProtocolType*

Ellipsis

Provides a typesafe way of calling ARC4 methods via an inner transaction

```python
def abi_call(
    self,
    method: Callable[..., _TABIResult_co] | str,
    /,
    *args: _TABIArg,
    app_id: algopy.Application | algopy.UInt64 | int = ...,
    on_completion: algopy.OnCompleteAction = ...,
    approval_program: algopy.Bytes | bytes | tuple[algopy.Bytes, ...] = ...,
    clear_state_program: algopy.Bytes | bytes | tuple[algopy.Bytes, ...] = ...,
    global_num_uint: UInt64 | int = ...,
    global_num_bytes: UInt64 | int = ...,
    local_num_uint: UInt64 | int = ...,
    local_num_bytes: UInt64 | int = ...,
    extra_program_pages: UInt64 | int = ...,
    fee: algopy.UInt64 | int = 0,
    sender: algopy.Account | str = ...,
    note: algopy.Bytes | algopy.String | bytes | str = ...,
    rekey_to: algopy.Account | str = ...,
) -> tuple[_TABIResult_co, algopy.itxn.ApplicationCallInnerTransaction]: ...
```

PARAMETERS:

**method:** The name, method selector or Algorand Python method to call\<br /\>
\\\\
**app_id:** Application to call, if 0 or not specified will create a new application\<br /\>
\\\\
**on_completion:** OnCompleteAction value for the transaction. If not specified will be inferred from Algorand Python method where possible\<br /\>
\\\\
**approval_program:** When creating or updating an application, the approval program\<br /\>
\\\\
**clear_state_program:** When creating or updating an application, the clear state program\<br /\>
\\\\
**global_num_uint:** When creating an application the number of global uints\<br /\>
\\\\
**global_num_bytes:** When creating an application the number of global bytes\<br /\>
\\\\
**local_num_uint:** When creating an application the number of local uints\<br /\>
\\\\
**local_num_bytes:** When creating an application the number of local bytes\<br /\>
\\\\
**extra_program_pages:** When creating an application the The number of extra program pages\<br /\>
\\\\
**fee:** The fee to pay for the transaction, defaults to 0\<br /\>
\\\\
**sender:** The sender address for the transaction\<br /\>
\\\\
**note:** Note to include with the transaction\<br /\>
\\\\
**rekey_to:** Account to rekey to

RETURNS:\<br /\>
\\\\
If `method` references an Algorand Contract / Client or the function is indexed with a return type,
then the result is a tuple containing the ABI result and the inner transaction of the call.

If no return type is specified, or the method does not have a return value then the result
is the inner transaction of the call.

Examples:

```default
# can reference another algopy contract method
result, txn = abi_call(HelloWorldContract.hello, arc4.String("World"), app=...)
assert result == "Hello, World"

# can reference a method selector
result, txn = abi_call[arc4.String]("hello(string)string", arc4.String("Algo"), app=...)
assert result == "Hello, Algo"

# can reference a method name, the method selector is inferred from arguments and return type
result, txn = abi_call[arc4.String]("hello", "There", app=...)
assert result == "Hello, There"

# calling a method without a return value
txn = abi_call(HelloWorldContract.no_return, arc4.String("World"), app=...)
```

<a id="algopy.arc4.abimethod"></a>

## algopy.arc4.abimethod(\*, name: str = ..., create: Literal[allow, require, disallow] = 'disallow', allow_actions: collections.abc.Sequence[[algopy.OnCompleteAction](algopy.mdx#algopy.OnCompleteAction) | Literal[NoOp, OptIn, CloseOut, UpdateApplication, DeleteApplication]] = ('NoOp',), readonly: bool = False, default_args: collections.abc.Mapping[str, str | algopy.arc4._ReadOnlyNoArgsMethod] = ...) → collections.abc.Callable[[collections.abc.Callable[algopy.arc4._P, algopy.arc4._R]], collections.abc.Callable[algopy.arc4._P, algopy.arc4._R]]

Decorator that indicates a method is an ARC4 ABI method.

:arg name: Name component of the ABI method selector. Defaults to using the function name.
:arg create: Controls the validation of the Application ID. “require” means it must be zero,
“disallow” requires it must be non-zero, and “allow” disables the validation.
:arg allow_actions: A sequence of allowed On-Completion Actions to validate against.
:arg readonly: If True, then this method can be used via dry-run / simulate.
:arg default_args: Default argument sources for clients to use.

<a id="algopy.arc4.arc4_create"></a>

## algopy.arc4.arc4_create(method: collections.abc.Callable[algopy.arc4._P, algopy.arc4._TABIResult_co], /, \*args: object, compiled: [algopy.CompiledContract](algopy.mdx#algopy.CompiledContract) = ..., on_completion: [algopy.OnCompleteAction](algopy.mdx#algopy.OnCompleteAction) = ..., fee: [algopy.UInt64](algopy.mdx#algopy.UInt64) | int = 0, sender: [algopy.Account](algopy.mdx#algopy.Account) | str = ..., note: [algopy.Bytes](algopy.mdx#algopy.Bytes) | bytes | str = ..., rekey_to: [algopy.Account](algopy.mdx#algopy.Account) | str = ...) → tuple[algopy.arc4._TABIResult_co, [algopy.itxn.ApplicationCallInnerTransaction](algopy.itxn.mdx#algopy.itxn.ApplicationCallInnerTransaction)]

Provides a typesafe and convenient way of creating an ARC4Contract via an inner transaction

:param method: An ARC4 create method (ABI or bare), or an ARC4Contract with a single create method
:param args: ABI args for chosen method
:param compiled: If supplied will be used to specify transaction parameters required for creation,
can be omitted if template variables are not used
:param on_completion: OnCompleteAction value for the transaction
If not specified will be inferred from Algorand Python method where possible
:param fee: The fee to pay for the transaction, defaults to 0
:param sender: The sender address for the transaction
:param note: Note to include with the transaction
:param rekey_to: Account to rekey to

<a id="algopy.arc4.arc4_signature"></a>

## algopy.arc4.arc4_signature(signature: str, /) → [algopy.Bytes](algopy.mdx#algopy.Bytes)

Returns the ARC4 encoded method selector for the specified signature

<a id="algopy.arc4.arc4_update"></a>

## algopy.arc4.arc4_update(method: collections.abc.Callable[algopy.arc4._P, algopy.arc4._TABIResult_co], /, \*args: object, app_id: [algopy.Application](algopy.mdx#algopy.Application) | [algopy.UInt64](algopy.mdx#algopy.UInt64) | int, compiled: [algopy.CompiledContract](algopy.mdx#algopy.CompiledContract) = ..., fee: [algopy.UInt64](algopy.mdx#algopy.UInt64) | int = 0, sender: [algopy.Account](algopy.mdx#algopy.Account) | str = ..., note: [algopy.Bytes](algopy.mdx#algopy.Bytes) | bytes | str = ..., rekey_to: [algopy.Account](algopy.mdx#algopy.Account) | str = ...) → tuple[algopy.arc4._TABIResult_co, [algopy.itxn.ApplicationCallInnerTransaction](algopy.itxn.mdx#algopy.itxn.ApplicationCallInnerTransaction)]

Provides a typesafe and convenient way of updating an ARC4Contract via an inner transaction

:param method: An ARC4 update method (ABI or bare), or an ARC4Contract with a single update method
:param args: ABI args for chosen method
:param app_id: Application to update
:param compiled: If supplied will be used to specify transaction parameters required for updating,
can be omitted if template variables are not used
:param fee: The fee to pay for the transaction, defaults to 0
:param sender: The sender address for the transaction
:param note: Note to include with the transaction
:param rekey_to: Account to rekey to

<a id="algopy.arc4.baremethod"></a>

## algopy.arc4.baremethod(\*, create: Literal[allow, require, disallow] = 'disallow', allow_actions: collections.abc.Sequence[[algopy.OnCompleteAction](algopy.mdx#algopy.OnCompleteAction) | Literal[NoOp, OptIn, CloseOut, UpdateApplication, DeleteApplication]] = ...) → collections.abc.Callable[[collections.abc.Callable[[algopy.arc4._TARC4Contract], None]], collections.abc.Callable[[algopy.arc4._TARC4Contract], None]]

Decorator that indicates a method is an ARC4 bare method.

There can be only one bare method on a contract for each given On-Completion Action.

:arg create: Controls the validation of the Application ID. “require” means it must be zero,
“disallow” requires it must be non-zero, and “allow” disables the validation.
:arg allow_actions: Which On-Completion Action(s) to handle.

<a id="algopy.arc4.emit"></a>

## algopy.arc4.emit(event: str | [algopy.arc4.Struct](#algopy.arc4.Struct), /, \*args: object) → None

Emit an ARC-28 event for the provided event signature or name, and provided args.

:param event: Either an ARC4 Struct, an event name, or event signature.
\* If event is an ARC4 Struct, the event signature will be determined from the Struct name and fields
\* If event is a signature, then the following args will be typed checked to ensure they match.
\* If event is just a name, the event signature will be inferred from the name and following arguments

:param args: When event is a signature or name, args will be used as the event data.
They will all be encoded as single ARC4 Tuple

Example:

```default
from algopy import ARC4Contract, arc4


class Swapped(arc4.Struct):
    a: arc4.UInt64
    b: arc4.UInt64


class EventEmitter(ARC4Contract):
    @arc4.abimethod
    def emit_swapped(self, a: arc4.UInt64, b: arc4.UInt64) -> None:
        arc4.emit(Swapped(b, a))
        arc4.emit("Swapped(uint64,uint64)", b, a)
        arc4.emit("Swapped", b, a)
```
